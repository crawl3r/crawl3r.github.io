<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>DaaC2 - Using Discord as a C2 | Crawl3r</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="DaaC2 - Using Discord as a C2" />
<meta name="author" content="Crawl3r" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction It was a cold Sunday evening, and I was doing nothing but afk’ing cannonballs on OSRS (shout out to @TimGMichaud) when I had an urge to make something. I was thinking about a conversation I had on Friday with Sion (fellow colleague/hacker friend) about methods of dropping malware, communicating with C2’s, how implants go undetected but still communicate etc. I fired up VS code and built a skeleton project of a ‘client’ and a ‘server’. I immediately took a step back and thought ‘I have already made stuff using the common approach (http/https, GET/POST etc).’ I wanted to make something I hadn’t seen before as well as something that was brand new to me. It was then I thought about using Discord as my means of communication between a server (C2) and a client (agent). Short(ish) Disclaimer I don’t write Malware for a living, I am not a red teamer (I work as a pentester) so I don’t have a tonne of knowledge in this area. When I build a C2/agent I pretty much get it working to a point where I can use it to gain a foothold and then upgrade/migrate to something a bit more substantial (i.e meterpreter etc). I do however have a big interest in malware, agents, implants, etc so I do enjoy writing little tools and PoC’s to scratch an itch. What you see here is no where near ‘production’ ready. I doubt it would be useful on site or in an engagement but hopefully it covers an area which hasn’t been discovered or hopefully it helps you, the reader, to build your own or even discover how wonderful Go is to write in. Don’t get triggered, I write things in a tonne of languages, Go just happens to be my current flavour at the moment. Use whatever you guys want, as long as you can bypass basic detection then you’re off to a good start. Planning Before I started implementing anything, I needed to figure out what I need to get a working PoC and how I might go about it. First things first, how am I going to use Discord as a method of communication. What we know about Discord (basic, high level approach): Basically Skype but targetting gamers Any user can create a ‘server’ (something something vent) ‘Devs’ can create bots to automate certain features &lt;- interesting Although a user can create a ’server’ they don’t host anything themselves Multiple clients are available, all using their API to have seamless cross platform &lt;- also interesting Okay, so if you haven’t spotted something we could do already by my interesting hints, then let’s run through a brief possible approach: As we, the attacker, want to be able to issue commands to an agent on a remote system we can utilise the Discord client on the attacking system to send messages. We now want something to ‘receive’ those messages, the easiest approach would be to have a human on the other end - however, this isn’t a thing, so instead we want to create a bot to read the messages and react appropriately. So now we have a simple agent that should be able to receive a message and easily send a reply. We will want to utilise the Discord API to send and receive messages within our agent. Finally, we want to use a new ‘server’ created by us to ensure our messages don’t get ‘lost’ or our agents don’t get confused due to other users or a high amount of messages being thrown around. The above should give us a low quality implementation (v0.1 if you will). The rest of the post will be following a structure similar to the above, effectively breaking up each chunk of the project and explaining what I did to implement a working PoC. The final product (or as it currently stands) went a pretty big step further than the above. That will be covered towards the end (it’s pretty cool and probably my favourite bit). Creating our agent and making our initial PoC First things first, I needed to create an ‘agent’ executable that would be dropped on a target system. I used the discordgo (https://github.com/bwmarrin/discordgo) to hook into the API, without this project I wouldn’t have gotten anywhere near where I did in the short amount of time - so big thanks!! The agent now acted like a Discord bot, when it was executed it would log in to the Discord service and sit and wait. So far, so good. Oh I forgot to mention, before getting a bot to authenticate properly you need to go to the developer portal for Discord and create an ‘app’ followed by a ‘bot’. This will give you an authentication token which is used to successfully authenticate and bring your bot to life. Simple, but pretty important. Once you have this, add your bot to a server you want to use (I created a new one so it was just my bot and my personal account). In theory, you now have your means of communication between an agent and you (the attacker). So now I had an agent that did nothing. Strong start. But what do agents need to do? Well… anything really. I set up a listener that would fire off a function everytime a message was received in the server, and had the bot parse it. For now, the parser would just ‘assume’ that the message contained a system command and used the content of the message in a separate function, executing the command in the underlying OS. For arguments sake, I wrote this entire project in Mac OSX so in any examples I will be using Unix commands. Naturally, Go can be built too many different platforms so Windows (for example) could be done easily, in-fact it might exist in the project at the time of reading this - but it didn’t at the time of writing. Anyway, running the agent and sending the message ‘id’ from my personal Discord account would cause the agent to react and reply with the command output - listing my current system user and its groups, etc. Awesome, I have an agent that receives instructions from a fake C2. At this point, I thought “This is a working PoC of using Discord as a method of communication… done, right?” but my fear of being judged on Twitter (lel) beat me in to a corner so I wanted to build something much cooler. After a couple of hours of DnB and dev, the basic ‘manual’ message building had become something I was really happy with. Now, ultimately, I don’t like Discord. I think it’s awful, the client is meh and no one wants to have to sit in a glorified text box all day. Especially when we have terminals that do everything for us. The best solution is to just uninstall Discord and write a cli tool that does everything for us. I mean, we have the API bindings, a ‘dedicated’ server and a means of authenticating right? So why do we need all the extra crap that Discord comes with… short answer; we don’t. I think videos and pictures are worth way more than words so I will drop a video of the C2 and agent working together and then break down each feature I have implemented since the Twitter fear kicked in. Fun fact, I have shown this to a few people so far and they love it. I can’t wait for strangers to hate it and give me grief - it’s what we all live for right? RIGHT?! Anyway, here’s the video from the C2 point of view: So, as we can see, it’s quite a bit more than the initial implementation and plan. We now have the following features: A single discord bot is used for the C2 and the agents. Agents have unique ID’s assigned during initialisation. This allows multiple agents to be used and communicate at the same time. With targetted interaction, the correct agent will react/respond every time. All messages are chunks of base64 (secure, I know /flex - remember when I said this isn’t engagement ready? I wasn’t lying). These chunks of base64 are encoded JSON structures that hold various information: data body (target command, required data for task/job, command result etc) To / From ID’s so the server/agents know when to react/ignore messages Message ’type’ used when parsing to figure out the required steps The discord server becomes quite busy during communication, as expected. An example of the agent and server communicating via the Discord server can be seen in here: The ‘uname’ example shown in the screenshot below was completed using the following two messages sent to the agent and back to the server: From the server: {&quot;FromServer&quot;:true,&quot;ToID&quot;:&quot;bNuHqEb4&quot;,&quot;FromID&quot;:&quot;SERVER&quot;,&quot;MessageType&quot;:&quot;cmd&quot;,&quot;Data&quot;:&quot;uname&quot;} From the agent: {&quot;FromServer&quot;:false,&quot;ToID&quot;:&quot;&quot;,&quot;FromID&quot;:&quot;bNuHqEb4&quot;,&quot;MessageType&quot;:&quot;reply&quot;,&quot;Data&quot;:&quot;Darwin\n&quot;} Agents can inject raw shellcode into themselves (upgrade the shell, start a new process, do whatever). Initially I used cgo to perform this but I had a mare when it came to cross compiling. Apparently after a billion years of coding I still don’t know how to build projects properly so I just changed my implementation. It currently only works on Unix/Darwin, not Windows. Agents have a heartbeat and ping the server every minute (can be set to whatever value you want in the source) allowing the server to track which agents are alive and dead. These can be listed in a table, showing their ID’s for easy interaction. There is some form of persistence here, whereby the server checks if it knows about the pinging agent and adds it back to the server list for interaction if it has ‘forgotten’ about it. This would be handy if the server ever died and was relaunched as the agents would be able to let them know they are still alive (this should use some form of secret/token so a rogue agent couldn’t connect through to us if it was able to get the auth token from the Discord bot). An example heartbeat message structure can be seen below (decoded). In addition, the heartbeat can be see in the screenshot above - rendered in yellow: {&quot;FromServer&quot;:false,&quot;ToID&quot;:&quot;&quot;,&quot;FromID&quot;:&quot;bNuHqEb4&quot;,&quot;MessageType&quot;:&quot;ping&quot;,&quot;Data&quot;:&quot;Ping at: 2020-01-25 19:38:54.466929 +0000 GMT m=+61.316731943&quot;} There are different cli menu states, allowing for easy message building and specific agent interaction. In addition, help menus can be listed per state to see the different options available: All known agents can be listed in a table within the cli, showing information such as the hostname, the systems external facing IP, their OS (very buggy) and their agentID for easy interaction. This is show below, when issuing the ‘agents’. Agents can be killed by the server on request, removing them from the server and shutting down the process (executable will still remain on the system though of course). This can be seen in the following screenshot, issuing the ‘kill’ option whilst interacting with an Agent. I haven’t dived into each of the above too much as hopefully the video shows it all off and as the source is available (https://github.com/crawl3r/DaaC2) - you can dive in and see what you can figure out. If you have any questions, suggestions or want me to cover each of the features more, tweet me and I can sort something out. Finally, I am likely going to continue developing this as I really enjoyed the couple of hours I spent making it. I think with more time, it could grow pretty nicely. So far, I haven’t spent any time implementing methods of evading AV or trying to hide on the target system so it is likely that it will get caught or flagged almost instantly. So you know, be smart. Don’t be a skid like me. Thanks for checking out my current project, hope you like it. If not, cool - I’m sure you can do miles better, right? Send it me when you have &lt;3" />
<meta property="og:description" content="Introduction It was a cold Sunday evening, and I was doing nothing but afk’ing cannonballs on OSRS (shout out to @TimGMichaud) when I had an urge to make something. I was thinking about a conversation I had on Friday with Sion (fellow colleague/hacker friend) about methods of dropping malware, communicating with C2’s, how implants go undetected but still communicate etc. I fired up VS code and built a skeleton project of a ‘client’ and a ‘server’. I immediately took a step back and thought ‘I have already made stuff using the common approach (http/https, GET/POST etc).’ I wanted to make something I hadn’t seen before as well as something that was brand new to me. It was then I thought about using Discord as my means of communication between a server (C2) and a client (agent). Short(ish) Disclaimer I don’t write Malware for a living, I am not a red teamer (I work as a pentester) so I don’t have a tonne of knowledge in this area. When I build a C2/agent I pretty much get it working to a point where I can use it to gain a foothold and then upgrade/migrate to something a bit more substantial (i.e meterpreter etc). I do however have a big interest in malware, agents, implants, etc so I do enjoy writing little tools and PoC’s to scratch an itch. What you see here is no where near ‘production’ ready. I doubt it would be useful on site or in an engagement but hopefully it covers an area which hasn’t been discovered or hopefully it helps you, the reader, to build your own or even discover how wonderful Go is to write in. Don’t get triggered, I write things in a tonne of languages, Go just happens to be my current flavour at the moment. Use whatever you guys want, as long as you can bypass basic detection then you’re off to a good start. Planning Before I started implementing anything, I needed to figure out what I need to get a working PoC and how I might go about it. First things first, how am I going to use Discord as a method of communication. What we know about Discord (basic, high level approach): Basically Skype but targetting gamers Any user can create a ‘server’ (something something vent) ‘Devs’ can create bots to automate certain features &lt;- interesting Although a user can create a ’server’ they don’t host anything themselves Multiple clients are available, all using their API to have seamless cross platform &lt;- also interesting Okay, so if you haven’t spotted something we could do already by my interesting hints, then let’s run through a brief possible approach: As we, the attacker, want to be able to issue commands to an agent on a remote system we can utilise the Discord client on the attacking system to send messages. We now want something to ‘receive’ those messages, the easiest approach would be to have a human on the other end - however, this isn’t a thing, so instead we want to create a bot to read the messages and react appropriately. So now we have a simple agent that should be able to receive a message and easily send a reply. We will want to utilise the Discord API to send and receive messages within our agent. Finally, we want to use a new ‘server’ created by us to ensure our messages don’t get ‘lost’ or our agents don’t get confused due to other users or a high amount of messages being thrown around. The above should give us a low quality implementation (v0.1 if you will). The rest of the post will be following a structure similar to the above, effectively breaking up each chunk of the project and explaining what I did to implement a working PoC. The final product (or as it currently stands) went a pretty big step further than the above. That will be covered towards the end (it’s pretty cool and probably my favourite bit). Creating our agent and making our initial PoC First things first, I needed to create an ‘agent’ executable that would be dropped on a target system. I used the discordgo (https://github.com/bwmarrin/discordgo) to hook into the API, without this project I wouldn’t have gotten anywhere near where I did in the short amount of time - so big thanks!! The agent now acted like a Discord bot, when it was executed it would log in to the Discord service and sit and wait. So far, so good. Oh I forgot to mention, before getting a bot to authenticate properly you need to go to the developer portal for Discord and create an ‘app’ followed by a ‘bot’. This will give you an authentication token which is used to successfully authenticate and bring your bot to life. Simple, but pretty important. Once you have this, add your bot to a server you want to use (I created a new one so it was just my bot and my personal account). In theory, you now have your means of communication between an agent and you (the attacker). So now I had an agent that did nothing. Strong start. But what do agents need to do? Well… anything really. I set up a listener that would fire off a function everytime a message was received in the server, and had the bot parse it. For now, the parser would just ‘assume’ that the message contained a system command and used the content of the message in a separate function, executing the command in the underlying OS. For arguments sake, I wrote this entire project in Mac OSX so in any examples I will be using Unix commands. Naturally, Go can be built too many different platforms so Windows (for example) could be done easily, in-fact it might exist in the project at the time of reading this - but it didn’t at the time of writing. Anyway, running the agent and sending the message ‘id’ from my personal Discord account would cause the agent to react and reply with the command output - listing my current system user and its groups, etc. Awesome, I have an agent that receives instructions from a fake C2. At this point, I thought “This is a working PoC of using Discord as a method of communication… done, right?” but my fear of being judged on Twitter (lel) beat me in to a corner so I wanted to build something much cooler. After a couple of hours of DnB and dev, the basic ‘manual’ message building had become something I was really happy with. Now, ultimately, I don’t like Discord. I think it’s awful, the client is meh and no one wants to have to sit in a glorified text box all day. Especially when we have terminals that do everything for us. The best solution is to just uninstall Discord and write a cli tool that does everything for us. I mean, we have the API bindings, a ‘dedicated’ server and a means of authenticating right? So why do we need all the extra crap that Discord comes with… short answer; we don’t. I think videos and pictures are worth way more than words so I will drop a video of the C2 and agent working together and then break down each feature I have implemented since the Twitter fear kicked in. Fun fact, I have shown this to a few people so far and they love it. I can’t wait for strangers to hate it and give me grief - it’s what we all live for right? RIGHT?! Anyway, here’s the video from the C2 point of view: So, as we can see, it’s quite a bit more than the initial implementation and plan. We now have the following features: A single discord bot is used for the C2 and the agents. Agents have unique ID’s assigned during initialisation. This allows multiple agents to be used and communicate at the same time. With targetted interaction, the correct agent will react/respond every time. All messages are chunks of base64 (secure, I know /flex - remember when I said this isn’t engagement ready? I wasn’t lying). These chunks of base64 are encoded JSON structures that hold various information: data body (target command, required data for task/job, command result etc) To / From ID’s so the server/agents know when to react/ignore messages Message ’type’ used when parsing to figure out the required steps The discord server becomes quite busy during communication, as expected. An example of the agent and server communicating via the Discord server can be seen in here: The ‘uname’ example shown in the screenshot below was completed using the following two messages sent to the agent and back to the server: From the server: {&quot;FromServer&quot;:true,&quot;ToID&quot;:&quot;bNuHqEb4&quot;,&quot;FromID&quot;:&quot;SERVER&quot;,&quot;MessageType&quot;:&quot;cmd&quot;,&quot;Data&quot;:&quot;uname&quot;} From the agent: {&quot;FromServer&quot;:false,&quot;ToID&quot;:&quot;&quot;,&quot;FromID&quot;:&quot;bNuHqEb4&quot;,&quot;MessageType&quot;:&quot;reply&quot;,&quot;Data&quot;:&quot;Darwin\n&quot;} Agents can inject raw shellcode into themselves (upgrade the shell, start a new process, do whatever). Initially I used cgo to perform this but I had a mare when it came to cross compiling. Apparently after a billion years of coding I still don’t know how to build projects properly so I just changed my implementation. It currently only works on Unix/Darwin, not Windows. Agents have a heartbeat and ping the server every minute (can be set to whatever value you want in the source) allowing the server to track which agents are alive and dead. These can be listed in a table, showing their ID’s for easy interaction. There is some form of persistence here, whereby the server checks if it knows about the pinging agent and adds it back to the server list for interaction if it has ‘forgotten’ about it. This would be handy if the server ever died and was relaunched as the agents would be able to let them know they are still alive (this should use some form of secret/token so a rogue agent couldn’t connect through to us if it was able to get the auth token from the Discord bot). An example heartbeat message structure can be seen below (decoded). In addition, the heartbeat can be see in the screenshot above - rendered in yellow: {&quot;FromServer&quot;:false,&quot;ToID&quot;:&quot;&quot;,&quot;FromID&quot;:&quot;bNuHqEb4&quot;,&quot;MessageType&quot;:&quot;ping&quot;,&quot;Data&quot;:&quot;Ping at: 2020-01-25 19:38:54.466929 +0000 GMT m=+61.316731943&quot;} There are different cli menu states, allowing for easy message building and specific agent interaction. In addition, help menus can be listed per state to see the different options available: All known agents can be listed in a table within the cli, showing information such as the hostname, the systems external facing IP, their OS (very buggy) and their agentID for easy interaction. This is show below, when issuing the ‘agents’. Agents can be killed by the server on request, removing them from the server and shutting down the process (executable will still remain on the system though of course). This can be seen in the following screenshot, issuing the ‘kill’ option whilst interacting with an Agent. I haven’t dived into each of the above too much as hopefully the video shows it all off and as the source is available (https://github.com/crawl3r/DaaC2) - you can dive in and see what you can figure out. If you have any questions, suggestions or want me to cover each of the features more, tweet me and I can sort something out. Finally, I am likely going to continue developing this as I really enjoyed the couple of hours I spent making it. I think with more time, it could grow pretty nicely. So far, I haven’t spent any time implementing methods of evading AV or trying to hide on the target system so it is likely that it will get caught or flagged almost instantly. So you know, be smart. Don’t be a skid like me. Thanks for checking out my current project, hope you like it. If not, cool - I’m sure you can do miles better, right? Send it me when you have &lt;3" />
<link rel="canonical" href="http://localhost:4000/2020-01-25/DaaC2" />
<meta property="og:url" content="http://localhost:4000/2020-01-25/DaaC2" />
<meta property="og:site_name" content="Crawl3r" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-01-25T00:00:00+00:00" />
<script type="application/ld+json">
{"description":"Introduction It was a cold Sunday evening, and I was doing nothing but afk’ing cannonballs on OSRS (shout out to @TimGMichaud) when I had an urge to make something. I was thinking about a conversation I had on Friday with Sion (fellow colleague/hacker friend) about methods of dropping malware, communicating with C2’s, how implants go undetected but still communicate etc. I fired up VS code and built a skeleton project of a ‘client’ and a ‘server’. I immediately took a step back and thought ‘I have already made stuff using the common approach (http/https, GET/POST etc).’ I wanted to make something I hadn’t seen before as well as something that was brand new to me. It was then I thought about using Discord as my means of communication between a server (C2) and a client (agent). Short(ish) Disclaimer I don’t write Malware for a living, I am not a red teamer (I work as a pentester) so I don’t have a tonne of knowledge in this area. When I build a C2/agent I pretty much get it working to a point where I can use it to gain a foothold and then upgrade/migrate to something a bit more substantial (i.e meterpreter etc). I do however have a big interest in malware, agents, implants, etc so I do enjoy writing little tools and PoC’s to scratch an itch. What you see here is no where near ‘production’ ready. I doubt it would be useful on site or in an engagement but hopefully it covers an area which hasn’t been discovered or hopefully it helps you, the reader, to build your own or even discover how wonderful Go is to write in. Don’t get triggered, I write things in a tonne of languages, Go just happens to be my current flavour at the moment. Use whatever you guys want, as long as you can bypass basic detection then you’re off to a good start. Planning Before I started implementing anything, I needed to figure out what I need to get a working PoC and how I might go about it. First things first, how am I going to use Discord as a method of communication. What we know about Discord (basic, high level approach): Basically Skype but targetting gamers Any user can create a ‘server’ (something something vent) ‘Devs’ can create bots to automate certain features &lt;- interesting Although a user can create a ’server’ they don’t host anything themselves Multiple clients are available, all using their API to have seamless cross platform &lt;- also interesting Okay, so if you haven’t spotted something we could do already by my interesting hints, then let’s run through a brief possible approach: As we, the attacker, want to be able to issue commands to an agent on a remote system we can utilise the Discord client on the attacking system to send messages. We now want something to ‘receive’ those messages, the easiest approach would be to have a human on the other end - however, this isn’t a thing, so instead we want to create a bot to read the messages and react appropriately. So now we have a simple agent that should be able to receive a message and easily send a reply. We will want to utilise the Discord API to send and receive messages within our agent. Finally, we want to use a new ‘server’ created by us to ensure our messages don’t get ‘lost’ or our agents don’t get confused due to other users or a high amount of messages being thrown around. The above should give us a low quality implementation (v0.1 if you will). The rest of the post will be following a structure similar to the above, effectively breaking up each chunk of the project and explaining what I did to implement a working PoC. The final product (or as it currently stands) went a pretty big step further than the above. That will be covered towards the end (it’s pretty cool and probably my favourite bit). Creating our agent and making our initial PoC First things first, I needed to create an ‘agent’ executable that would be dropped on a target system. I used the discordgo (https://github.com/bwmarrin/discordgo) to hook into the API, without this project I wouldn’t have gotten anywhere near where I did in the short amount of time - so big thanks!! The agent now acted like a Discord bot, when it was executed it would log in to the Discord service and sit and wait. So far, so good. Oh I forgot to mention, before getting a bot to authenticate properly you need to go to the developer portal for Discord and create an ‘app’ followed by a ‘bot’. This will give you an authentication token which is used to successfully authenticate and bring your bot to life. Simple, but pretty important. Once you have this, add your bot to a server you want to use (I created a new one so it was just my bot and my personal account). In theory, you now have your means of communication between an agent and you (the attacker). So now I had an agent that did nothing. Strong start. But what do agents need to do? Well… anything really. I set up a listener that would fire off a function everytime a message was received in the server, and had the bot parse it. For now, the parser would just ‘assume’ that the message contained a system command and used the content of the message in a separate function, executing the command in the underlying OS. For arguments sake, I wrote this entire project in Mac OSX so in any examples I will be using Unix commands. Naturally, Go can be built too many different platforms so Windows (for example) could be done easily, in-fact it might exist in the project at the time of reading this - but it didn’t at the time of writing. Anyway, running the agent and sending the message ‘id’ from my personal Discord account would cause the agent to react and reply with the command output - listing my current system user and its groups, etc. Awesome, I have an agent that receives instructions from a fake C2. At this point, I thought “This is a working PoC of using Discord as a method of communication… done, right?” but my fear of being judged on Twitter (lel) beat me in to a corner so I wanted to build something much cooler. After a couple of hours of DnB and dev, the basic ‘manual’ message building had become something I was really happy with. Now, ultimately, I don’t like Discord. I think it’s awful, the client is meh and no one wants to have to sit in a glorified text box all day. Especially when we have terminals that do everything for us. The best solution is to just uninstall Discord and write a cli tool that does everything for us. I mean, we have the API bindings, a ‘dedicated’ server and a means of authenticating right? So why do we need all the extra crap that Discord comes with… short answer; we don’t. I think videos and pictures are worth way more than words so I will drop a video of the C2 and agent working together and then break down each feature I have implemented since the Twitter fear kicked in. Fun fact, I have shown this to a few people so far and they love it. I can’t wait for strangers to hate it and give me grief - it’s what we all live for right? RIGHT?! Anyway, here’s the video from the C2 point of view: So, as we can see, it’s quite a bit more than the initial implementation and plan. We now have the following features: A single discord bot is used for the C2 and the agents. Agents have unique ID’s assigned during initialisation. This allows multiple agents to be used and communicate at the same time. With targetted interaction, the correct agent will react/respond every time. All messages are chunks of base64 (secure, I know /flex - remember when I said this isn’t engagement ready? I wasn’t lying). These chunks of base64 are encoded JSON structures that hold various information: data body (target command, required data for task/job, command result etc) To / From ID’s so the server/agents know when to react/ignore messages Message ’type’ used when parsing to figure out the required steps The discord server becomes quite busy during communication, as expected. An example of the agent and server communicating via the Discord server can be seen in here: The ‘uname’ example shown in the screenshot below was completed using the following two messages sent to the agent and back to the server: From the server: {&quot;FromServer&quot;:true,&quot;ToID&quot;:&quot;bNuHqEb4&quot;,&quot;FromID&quot;:&quot;SERVER&quot;,&quot;MessageType&quot;:&quot;cmd&quot;,&quot;Data&quot;:&quot;uname&quot;} From the agent: {&quot;FromServer&quot;:false,&quot;ToID&quot;:&quot;&quot;,&quot;FromID&quot;:&quot;bNuHqEb4&quot;,&quot;MessageType&quot;:&quot;reply&quot;,&quot;Data&quot;:&quot;Darwin\\n&quot;} Agents can inject raw shellcode into themselves (upgrade the shell, start a new process, do whatever). Initially I used cgo to perform this but I had a mare when it came to cross compiling. Apparently after a billion years of coding I still don’t know how to build projects properly so I just changed my implementation. It currently only works on Unix/Darwin, not Windows. Agents have a heartbeat and ping the server every minute (can be set to whatever value you want in the source) allowing the server to track which agents are alive and dead. These can be listed in a table, showing their ID’s for easy interaction. There is some form of persistence here, whereby the server checks if it knows about the pinging agent and adds it back to the server list for interaction if it has ‘forgotten’ about it. This would be handy if the server ever died and was relaunched as the agents would be able to let them know they are still alive (this should use some form of secret/token so a rogue agent couldn’t connect through to us if it was able to get the auth token from the Discord bot). An example heartbeat message structure can be seen below (decoded). In addition, the heartbeat can be see in the screenshot above - rendered in yellow: {&quot;FromServer&quot;:false,&quot;ToID&quot;:&quot;&quot;,&quot;FromID&quot;:&quot;bNuHqEb4&quot;,&quot;MessageType&quot;:&quot;ping&quot;,&quot;Data&quot;:&quot;Ping at: 2020-01-25 19:38:54.466929 +0000 GMT m=+61.316731943&quot;} There are different cli menu states, allowing for easy message building and specific agent interaction. In addition, help menus can be listed per state to see the different options available: All known agents can be listed in a table within the cli, showing information such as the hostname, the systems external facing IP, their OS (very buggy) and their agentID for easy interaction. This is show below, when issuing the ‘agents’. Agents can be killed by the server on request, removing them from the server and shutting down the process (executable will still remain on the system though of course). This can be seen in the following screenshot, issuing the ‘kill’ option whilst interacting with an Agent. I haven’t dived into each of the above too much as hopefully the video shows it all off and as the source is available (https://github.com/crawl3r/DaaC2) - you can dive in and see what you can figure out. If you have any questions, suggestions or want me to cover each of the features more, tweet me and I can sort something out. Finally, I am likely going to continue developing this as I really enjoyed the couple of hours I spent making it. I think with more time, it could grow pretty nicely. So far, I haven’t spent any time implementing methods of evading AV or trying to hide on the target system so it is likely that it will get caught or flagged almost instantly. So you know, be smart. Don’t be a skid like me. Thanks for checking out my current project, hope you like it. If not, cool - I’m sure you can do miles better, right? Send it me when you have &lt;3","author":{"@type":"Person","name":"Crawl3r"},"@type":"BlogPosting","url":"http://localhost:4000/2020-01-25/DaaC2","headline":"DaaC2 - Using Discord as a C2","dateModified":"2020-01-25T00:00:00+00:00","datePublished":"2020-01-25T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020-01-25/DaaC2"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Crawl3r" />

</head>


  <body>

    <nav class="nav">
  <div class="nav-container">
    <a href="/">
      <h2 class="nav-title">Crawl3r</h2>
    </a>
    
    <ul>
      <li><a href="/about">About</a></li>
      <li><a href="/">Posts</a></li>
    </ul>
  </div>
</nav>


    <main>
      <div class="post">
  <div class="post-info">
    <span>Written by</span>
    
        Crawl3r
    

    
      <br>
      <span>on&nbsp;</span><time datetime="2020-01-25 00:00:00 +0000">January 25, 2020</time>
    
  </div>

  <h1 class="post-title">DaaC2 - Using Discord as a C2</h1>
  <div class="post-line"></div>

  <h2 id="introduction">Introduction</h2>
<p>It was a cold Sunday evening, and I was doing nothing but afk’ing cannonballs on OSRS (shout out to @TimGMichaud) when I had an urge to make something. I was thinking about a conversation I had on Friday with Sion (fellow colleague/hacker friend) about methods of dropping malware, communicating with C2’s, how implants go undetected but still communicate etc. I fired up VS code and built a skeleton project of a ‘client’ and a ‘server’. I immediately took a step back and thought ‘I have already made stuff using the common approach (http/https, GET/POST etc).’ I wanted to make something I hadn’t seen before as well as something that was brand new to me. It was then I thought about using Discord as my means of communication between a server (C2) and a client (agent).</p>

<h2 id="shortish-disclaimer">Short(ish) Disclaimer</h2>
<p>I don’t write Malware for a living, I am not a red teamer (I work as a pentester) so I don’t have a tonne of knowledge in this area. When I build a C2/agent I pretty much get it working to a point where I can use it to gain a foothold and then upgrade/migrate to something a bit more substantial (i.e meterpreter etc). I do however have a big interest in malware, agents, implants, etc so I do enjoy writing little tools and PoC’s to scratch an itch. What you see here is no where near ‘production’ ready. I doubt it would be useful on site or in an engagement but hopefully it covers an area which hasn’t been discovered or hopefully it helps you, the reader, to build your own or even discover how wonderful Go is to write in. Don’t get triggered, I write things in a tonne of languages, Go just happens to be my current flavour at the moment. Use whatever you guys want, as long as you can bypass basic detection then you’re off to a good start.</p>

<h2 id="planning">Planning</h2>
<p>Before I started implementing anything, I needed to figure out what I need to get a working PoC and how I might go about it. First things first, how am I going to use Discord as a method of communication.</p>

<p>What we know about Discord (basic, high level approach):</p>
<ul>
  <li>Basically Skype but targetting gamers</li>
  <li>Any user can create a ‘server’ (something something vent)</li>
  <li>‘Devs’ can create bots to automate certain features &lt;- <em>interesting</em></li>
  <li>Although a user can create a ’server’ they don’t host anything themselves</li>
  <li>Multiple clients are available, all using their API to have seamless cross platform &lt;- <em>also interesting</em></li>
</ul>

<p>Okay, so if you haven’t spotted something we could do already by my interesting hints, then let’s run through a brief possible approach:</p>

<p>As we, the attacker, want to be able to issue commands to an agent on a remote system we can utilise the Discord client on the attacking system to send messages. We now want something to ‘receive’ those messages, the easiest approach would be to have a human on the other end - however, this isn’t a thing, so instead we want to create a bot to read the messages and react appropriately. So now we have a simple agent that should be able to receive a message and easily send a reply. We will want to utilise the Discord API to send and receive messages within our agent. Finally, we want to use a new ‘server’ created by us to ensure our messages don’t get ‘lost’ or our agents don’t get confused due to other users or a high amount of messages being thrown around.</p>

<p>The above should give us a low quality implementation (v0.1 if you will). The rest of the post will be following a structure similar to the above, effectively breaking up each chunk of the project and explaining what I did to implement a working PoC. The final product (or as it currently stands) went a pretty big step further than the above. That will be covered towards the end (it’s pretty cool and probably my favourite bit).</p>

<h2 id="creating-our-agent-and-making-our-initial-poc">Creating our agent and making our initial PoC</h2>
<p>First things first, I needed to create an ‘agent’ executable that would be dropped on a target system. I used the discordgo (https://github.com/bwmarrin/discordgo) to hook into the API, without this project I wouldn’t have gotten anywhere near where I did in the short amount of time - so big thanks!! The agent now acted like a Discord bot, when it was executed it would log in to the Discord service and sit and wait. So far, so good. Oh I forgot to mention, before getting a bot to authenticate properly you need to go to the developer portal for Discord and create an ‘app’ followed by a ‘bot’. This will give you an authentication token which is used to successfully authenticate and bring your bot to life. Simple, but pretty important. Once you have this, add your bot to a server you want to use (I created a new one so it was just my bot and my personal account). In theory, you now have your means of communication between an agent and you (the attacker).</p>

<p>So now I had an agent that did nothing. Strong start. But what do agents need to do? Well… anything really. I set up a listener that would fire off a function everytime a message was received in the server, and had the bot parse it. For now, the parser would just ‘assume’ that the message contained a system command and used the content of the message in a separate function, executing the command in the underlying OS. For arguments sake, I wrote this entire project in Mac OSX so in any examples I will be using Unix commands. Naturally, Go can be built too many different platforms so Windows (for example) could be done easily, in-fact it might exist in the project at the time of reading this - but it didn’t at the time of writing. Anyway, running the agent and sending the message ‘id’ from my personal Discord account would cause the agent to react and reply with the command output - listing my current system user and its groups, etc. Awesome, I have an agent that receives instructions from a fake C2. At this point, I thought “This is a working PoC of using Discord as a method of communication… done, right?” but my fear of being judged on Twitter (lel) beat me in to a corner so I wanted to build something much cooler.</p>

<p>After a couple of hours of DnB and dev, the basic ‘manual’ message building had become something I was really happy with.</p>

<p>Now, ultimately, I don’t like Discord. I think it’s awful, the client is meh and no one wants to have to sit in a glorified text box all day. Especially when we have terminals that do everything for us. The best solution is to just uninstall Discord and write a cli tool that does everything for us. I mean, we have the API bindings, a ‘dedicated’ server and a means of authenticating right? So why do we need all the extra crap that Discord comes with… short answer; we don’t.</p>

<p>I think videos and pictures are worth way more than words so I will drop a video of the C2 and agent working together and then break down each feature I have implemented since the Twitter fear kicked in. Fun fact, I have shown this to a few people so far and they love it. I can’t wait for strangers to hate it and give me grief - it’s what we all live for right? RIGHT?! Anyway, here’s the video from the C2 point of view:</p>

<p><a href="https://asciinema.org/a/MhxrTKcTwDANV3IbWiUo2CpVM"><img src="https://asciinema.org/a/MhxrTKcTwDANV3IbWiUo2CpVM.svg" alt="asciicast" /></a></p>

<p>So, as we can see, it’s quite a bit more than the initial implementation and plan. We now have the following features:</p>

<p>A single discord bot is used for the C2 and the agents.</p>

<p>Agents have unique ID’s assigned during initialisation. This allows multiple agents to be used and communicate at the same time. With targetted interaction, the correct agent will react/respond every time.</p>

<p>All messages are chunks of base64 (secure, I know /flex - remember when I said this isn’t engagement ready? I wasn’t lying). These chunks of base64 are encoded JSON structures that hold various information:</p>
<ul>
  <li>data body (target command, required data for task/job, command result etc)</li>
  <li>To / From ID’s so the server/agents know when to react/ignore messages</li>
  <li>Message ’type’ used when parsing to figure out the required steps</li>
</ul>

<p>The discord server becomes quite busy during communication, as expected. An example of the agent and server communicating via the Discord server can be seen in here:</p>

<p><img src="http://localhost:4000/assets/images/DaaC2/discord_1.png" alt="Discord communication" /></p>

<p>The ‘uname’ example shown in the screenshot below was completed using the following two messages sent to the agent and back to the server:</p>

<p>From the server:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{"FromServer":true,"ToID":"bNuHqEb4","FromID":"SERVER","MessageType":"cmd","Data":"uname"}
</code></pre></div></div>

<p>From the agent:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{"FromServer":false,"ToID":"","FromID":"bNuHqEb4","MessageType":"reply","Data":"Darwin\n"}
</code></pre></div></div>

<p><img src="http://localhost:4000/assets/images/DaaC2/server_3.png" alt="Commands sent to Agent" /></p>

<p>Agents can inject raw shellcode into themselves (upgrade the shell, start a new process, do whatever). Initially I used cgo to perform this but I had a mare when it came to cross compiling. Apparently after a billion years of coding I still don’t know how to build projects properly so I just changed my implementation. It currently only works on Unix/Darwin, not Windows.</p>

<p>Agents have a heartbeat and ping the server every minute (can be set to whatever value you want in the source) allowing the server to track which agents are alive and dead. These can be listed in a table, showing their ID’s for easy interaction. There is some form of persistence here, whereby the server checks if it knows about the pinging agent and adds it back to the server list for interaction if it has ‘forgotten’ about it. This would be handy if the server ever died and was relaunched as the agents would be able to let them know they are still alive (this should use some form of secret/token so a rogue agent couldn’t connect through to us if it was able to get the auth token from the Discord bot). An example heartbeat message structure can be seen below (decoded). In addition, the heartbeat can be see in the screenshot above - rendered in yellow:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{"FromServer":false,"ToID":"","FromID":"bNuHqEb4","MessageType":"ping","Data":"Ping at: 2020-01-25 19:38:54.466929 +0000 GMT m=+61.316731943"}
</code></pre></div></div>

<p>There are different cli menu states, allowing for easy message building and specific agent interaction. In addition, help menus can be listed per state to see the different options available:</p>

<p><img src="http://localhost:4000/assets/images/DaaC2/server_2.png" alt="Help menu" /></p>

<p>All known agents can be listed in a table within the cli, showing information such as the hostname, the systems external facing IP, their OS (very buggy) and their agentID for easy interaction. This is show below, when issuing the ‘agents’.</p>

<p><img src="http://localhost:4000/assets/images/DaaC2/server_1.png" alt="Lising the connected agents" /></p>

<p>Agents can be killed by the server on request, removing them from the server and shutting down the process (executable will still remain on the system though of course). This can be seen in the following screenshot, issuing the ‘kill’ option whilst interacting with an Agent.</p>

<p><img src="http://localhost:4000/assets/images/DaaC2/server_4.png" alt="Killing the target agent" /></p>

<p>I haven’t dived into each of the above too much as hopefully the video shows it all off and as the source is available (https://github.com/crawl3r/DaaC2) - you can dive in and see what you can figure out. If you have any questions, suggestions or want me to cover each of the features more, tweet me and I can sort something out.</p>

<p>Finally, I am likely going to continue developing this as I really enjoyed the couple of hours I spent making it. I think with more time, it could grow pretty nicely. So far, I haven’t spent any time implementing methods of evading AV or trying to hide on the target system so it is likely that it will get caught or flagged almost instantly. So you know, be smart. Don’t be a skid like me.</p>

<p>Thanks for checking out my current project, hope you like it. If not, cool - I’m sure you can do miles better, right? Send it me when you have &lt;3</p>

</div>

<div class="pagination">
  
  
    <a href="/2020-01-12/slae32_tcp_reverse_shell" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>
    </main>

    <footer>
  <span>
    &copy; <time datetime="2020-01-25 23:21:52 +0000">2020</time> Crawl3r. Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.
  </span>
</footer>

  </body>
</html>
